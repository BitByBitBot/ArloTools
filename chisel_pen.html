<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Chisel‚ÄëTip Pen ‚Äî Brutalist</title>
<style>
  :root {
    --bg: #ffffff;
    --panel: #ffffff;
    --panel-2: #f7f7f7;
    --text: #000000;
    --muted: #444444;
    --btn: #ffffff;
    --btn-hover: #eeeeee;
    --grid: #cccccc;
  }
  * { box-sizing: border-box; }
  html, body { height: 100%; }
  body {
    margin: 0;
    background: var(--bg);
    color: var(--text);
    font: 14px/1.4 monospace;
  }
  .app {
    display: grid;
    grid-template-columns: 320px 1fr;
    grid-template-rows: auto 1fr;
    height: 100vh;
  }
  header {
    grid-column: 1 / 3;
    padding: 10px 12px;
    display: flex;
    gap: 10px;
    align-items: center;
    background: var(--panel);
    border-bottom: 2px solid black;
    position: sticky;
    top: 0;
    z-index: 3;
  }
  header h1 {
    font-size: 14px;
    margin: 0;
    letter-spacing: .02em;
    color: var(--muted);
    font-weight: bold;
  }
  .toolbar { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
  .side {
    padding: 12px;
    background: var(--panel);
    border-right: 2px solid black;
    overflow: auto;
  }
  .group { background: var(--panel-2); border: 2px solid black; padding: 10px; margin-bottom: 10px; }
  .group h3 { margin: 0 0 8px; font-size: 12px; color: var(--muted); font-weight: bold; text-transform: uppercase; letter-spacing: .08em; }
  label { display: grid; grid-template-columns: 1fr auto; gap: 8px; align-items: center; margin: 6px 0; }
  input[type="range"] { width: 180px; }
  input[type="number"] { width: 72px; background: white; color: black; border: 2px solid black; padding: 4px 6px; }
  input[type="checkbox"] { transform: scale(1.2); }
  .row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
  .btn { border: 2px solid black; background: var(--btn); color: black; padding: 8px 10px; cursor: pointer; }
  .btn:hover { background: var(--btn-hover); }
  .btn.primary { outline: 2px solid black; }
  .btn.eraser { background: #eee; }
  .swatch { width: 30px; height: 30px; border: 2px solid black; }
  #canvasWrap { position: relative; background: var(--bg); }
  canvas { display: block; width: 100%; height: 100%; background: transparent; cursor: crosshair; }
  .overlay { position: absolute; inset: 0; pointer-events: none; }
  .grid { position: absolute; inset: 0; background-size: 32px 32px, 8px 8px; background-image:
      linear-gradient(var(--grid) 1px, transparent 1px),
      linear-gradient(90deg, var(--grid) 1px, transparent 1px);
      pointer-events: none; z-index: 0; opacity: 0.6; }
  .readout { position: absolute; right: 10px; bottom: 10px; background: white; border: 2px solid black; padding: 6px 8px; font: 12px/1.2 monospace; color: black; }
  .kbd { font: 12px/1 monospace; background: white; border: 2px solid black; padding: 2px 5px; display: inline-block; }
  .help { color: var(--muted); font-size: 12px; }
</style>
</head>
<body>
  <div class="app">
    <header>
      <h1>Chisel‚ÄëTip Pen</h1>
      <div class="toolbar" id="toolbar">
        <button class="btn primary" id="penBtn" title="Pen (P)">‚úíÔ∏è Pen</button>
        <button class="btn eraser" id="eraserBtn" title="Eraser (E)">ü©π Eraser</button>
        <button class="btn" id="bezierBtn" title="Bezier Curves (B)">‚û∞ Bezier</button>
        <button class="btn" id="undoBtn" title="Undo (Ctrl/Cmd+Z)">‚Ü∂ Undo</button>
        <button class="btn" id="redoBtn" title="Redo (Ctrl/Cmd+Shift+Z)">‚Ü∑ Redo</button>
        <button class="btn" id="clearBtn" title="Clear (C)">üóë Clear</button>
        <button class="btn" id="saveBtn" title="Save PNG (S)">üíæ Save</button>
        <button class="btn" id="diagBtn" title="Run diagnostics">üß™ Test</button>
      </div>
    </header>

    <aside class="side">
      <div class="group">
        <h3>Nib</h3>
        <div class="row" style="gap:12px">
          <div>
            <div class="help">Color</div>
            <input id="color" type="color" value="#000000" />
          </div>
          <div>
            <div class="help">Opacity</div>
            <input id="opacity" type="range" min="0" max="1" step="0.01" value="1" />
          </div>
          <div class="swatch" id="swatch"></div>
        </div>
        <label>Width (broad) <input id="nibLen" type="range" min="4" max="200" step="1" value="50"></label>
        <label>Thickness (edge) <input id="nibThick" type="range" min="1" max="60" step="1" value="12"></label>
        <label>Angle <input id="angle" type="range" min="0" max="180" step="1" value="35"></label>
        <div class="help">Tip: change angle with <span class="kbd">[</span> and <span class="kbd">]</span></div>
      </div>

      <div class="group">
        <h3>Stroke</h3>
        <label>Spacing <input id="spacing" type="range" min="0.5" max="20" step="0.5" value="3"></label>
        <label>Smoothing (px) <input id="smoothing" type="range" min="0" max="20" step="1" value="2"></label>
        <label>Pressure affects
          <select id="pressureMode">
            <option value="off">Off</option>
            <option value="thick">Thickness</option>
            <option value="both">Both axes</option>
          </select>
        </label>
        <label>Jitter (px) <input id="jitter" type="range" min="0" max="3" step="0.1" value="0"></label>
      </div>

      <div class="group">
        <h3>Canvas</h3>
        <label>Size W √ó H
          <div class="row">
            <input id="cw" type="number" min="256" max="4096" step="1" value="1600">
            <input id="ch" type="number" min="256" max="4096" step="1" value="900">
            <button class="btn" id="resizeBtn">Resize</button>
          </div>
        </label>
        <label>Paper <select id="paper">
          <option value="transparent">Transparent</option>
          <option value="ivory" selected>Ivory</option>
          <option value="white">White</option>
          <option value="charcoal">Charcoal</option>
        </select></label>
        <label><span>Show grid</span> <input id="grid" type="checkbox" checked></label>
        <label><span>Dark UI</span> <input id="dark" type="checkbox"></label>
      </div>

      <div class="group">
        <h3>Shortcuts</h3>
        <div class="help">
          <p><span class="kbd">P</span> Pen ¬∑ <span class="kbd">E</span> Eraser ¬∑ <span class="kbd">B</span> Bezier ¬∑ <span class="kbd">[</span>/<span class="kbd">]</span> Angle ¬∑ <span class="kbd">C</span> Clear ¬∑ <span class="kbd">S</span> Save ¬∑ <span class="kbd">Z</span> Undo ¬∑ <span class="kbd">Shift+Z</span> Redo ¬∑ <span class="kbd">Esc</span> Cancel curve</p>
        </div>
      </div>
    </aside>

    <main id="canvasWrap">
      <div class="grid" id="gridLayer"></div>
      <canvas id="canvas"></canvas>
      <canvas id="overlay" class="overlay"></canvas>
      <div class="readout" id="readout"></div>
    </main>
  </div>

<script>
// Wrap all logic so DOM is ready before we query elements (fixes getContext null errors)
window.addEventListener('DOMContentLoaded', () => {
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const overlay = document.getElementById('overlay');
  const octx = overlay.getContext('2d');
  const gridLayer = document.getElementById('gridLayer');
  const readout = document.getElementById('readout');
  const swatch = document.getElementById('swatch');
  const diagBtn = document.getElementById('diagBtn');
  const inputs = {
    color: document.getElementById('color'),
    opacity: document.getElementById('opacity'),
    nibLen: document.getElementById('nibLen'),
    nibThick: document.getElementById('nibThick'),
    angle: document.getElementById('angle'),
    spacing: document.getElementById('spacing'),
    smoothing: document.getElementById('smoothing'),
    jitter: document.getElementById('jitter'),
    pressureMode: document.getElementById('pressureMode'),
    cw: document.getElementById('cw'),
    ch: document.getElementById('ch'),
    resizeBtn: document.getElementById('resizeBtn'),
    paper: document.getElementById('paper'),
    grid: document.getElementById('grid'),
    dark: document.getElementById('dark')
  };
  const buttons = {
    pen: document.getElementById('penBtn'),
    eraser: document.getElementById('eraserBtn'),
    bezier: document.getElementById('bezierBtn'),
    undo: document.getElementById('undoBtn'),
    redo: document.getElementById('redoBtn'),
    clear: document.getElementById('clearBtn'),
    save: document.getElementById('saveBtn')
  };

  // Basic diagnostics ("test cases") to catch DOM regressions quickly
  function runDiagnostics() {
    const results = [];
    function ok(cond, msg){ results.push({ok: !!cond, msg}); }
    ok(!!canvas, '#canvas exists');
    ok(!!ctx, 'canvas.getContext("2d") works');
    ok(!!overlay, '#overlay exists');
    ok(!!octx, 'overlay.getContext("2d") works');
    ['color','opacity','nibLen','nibThick','angle','spacing','smoothing','jitter','pressureMode','cw','ch','resizeBtn','paper','grid','dark']
      .forEach(id => ok(!!inputs[id], `#${id} exists`));
    ['pen','eraser','bezier','undo','redo','clear','save'].forEach(id => ok(!!buttons[id], `button ${id} exists`));
    const failed = results.filter(r=>!r.ok);
    console.table(results);
    readout.textContent = failed.length ? `Diagnostics: ${failed.length} issue(s)` : 'Diagnostics: OK';
  }
  diagBtn.addEventListener('click', runDiagnostics);

  let tool = 'pen';
  let drawing = false;
  let last = null; // {x,y}
  let carry = 0;   // leftover distance for spacing
  let undoStack = [], redoStack = [];
  const UNDO_LIMIT = 40;

  // Bezier state
  let bezierPts = []; // stores clicked points in canvas coords
  let mousePos = null;

  function setCanvasSize(w,h, preserve=true){
    w = Math.max(1, Math.floor(w));
    h = Math.max(1, Math.floor(h));
    let snapshot = null;
    if(preserve){ snapshot = canvas.toDataURL('image/png'); }
    canvas.width = w; canvas.height = h;
    overlay.width = w; overlay.height = h;
    fitCanvasToContainer();
    setPaper();
    clearOverlay();
    if(preserve && snapshot){
      const img = new Image();
      img.onload = ()=>{ ctx.drawImage(img,0,0); pushUndo(); };
      img.src = snapshot;
    } else {
      pushUndo();
    }
  }

  function fitCanvasToContainer(){ /* CSS scales */ }

  function setPaper(){
    const p = inputs.paper.value;
    let color = 'transparent';
    if(p==='ivory') color = '#f5f1e6';
    if(p==='white') color = '#ffffff';
    if(p==='charcoal') color = '#0f1115';
    const img = new Image();
    img.onload = ()=>{
      const tmp = document.createElement('canvas');
      tmp.width = canvas.width; tmp.height = canvas.height;
      const tctx = tmp.getContext('2d');
      if(color!=='transparent'){
        tctx.fillStyle = color; tctx.fillRect(0,0,tmp.width,tmp.height);
      }
      tctx.drawImage(canvas,0,0);
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.drawImage(tmp,0,0);
    };
    img.src = canvas.toDataURL();
  }

  function uiSync(){
    const c = inputs.color.value;
    const a = parseFloat(inputs.opacity.value);
    if(swatch){ swatch.style.background = c; swatch.style.opacity = a; }
    document.documentElement.style.setProperty('--grid', inputs.dark.checked? '#d8dbe2' : '#cccccc');
    document.body.style.setProperty('--bg', inputs.dark.checked? '#111417':'#ffffff');
    document.body.style.setProperty('--panel', inputs.dark.checked? '#1b2026':'#ffffff');
    document.body.style.setProperty('--panel-2', inputs.dark.checked? '#151a1f':'#f7f7f7');
    document.body.style.setProperty('--text', inputs.dark.checked? '#e7edf3':'#000000');
    document.body.style.setProperty('--muted', inputs.dark.checked? '#9db0c4':'#444444');
    gridLayer.style.display = inputs.grid.checked? 'block':'none';
    buttons.pen.classList.toggle('primary', tool==='pen');
    buttons.eraser.classList.toggle('primary', tool==='eraser');
    buttons.bezier.classList.toggle('primary', tool==='bezier');
  }

  function pushUndo(){
    try {
      undoStack.push(canvas.toDataURL('image/png'));
      if(undoStack.length>UNDO_LIMIT) undoStack.shift();
      redoStack.length = 0;
    } catch(e){ /* ignore */ }
  }

  function undo(){
    if(undoStack.length<2) return; // keep at least current state
    const current = undoStack.pop();
    redoStack.push(current);
    const dataURL = undoStack[undoStack.length-1];
    const img = new Image();
    img.onload = ()=>{ ctx.clearRect(0,0,canvas.width,canvas.height); ctx.drawImage(img,0,0); };
    img.src = dataURL;
  }
  function redo(){
    if(!redoStack.length) return;
    const dataURL = redoStack.pop();
    undoStack.push(dataURL);
    const img = new Image();
    img.onload = ()=>{ ctx.clearRect(0,0,canvas.width,canvas.height); ctx.drawImage(img,0,0); };
    img.src = dataURL;
  }

  function getSettings(evt){
    const color = inputs.color.value;
    const opacity = parseFloat(inputs.opacity.value);
    const nibLen = parseFloat(inputs.nibLen.value);
    const nibThickBase = parseFloat(inputs.nibThick.value);
    const angleDeg = parseFloat(inputs.angle.value);
    const spacing = Math.max(0.1, parseFloat(inputs.spacing.value));
    const smoothing = parseFloat(inputs.smoothing.value);
    const jitter = parseFloat(inputs.jitter.value);
    const pressure = evt && 'pressure' in evt ? Math.max(0.0, Math.min(1.0, evt.pressure || 0)) : 0.5;
    const pmode = inputs.pressureMode.value;
    let nibThick = nibThickBase;
    let nibLenEff = nibLen;
    if(pmode==='thick'){
      nibThick = nibThickBase * (0.3 + pressure*0.7);
    } else if(pmode==='both'){
      nibThick = nibThickBase * (0.3 + pressure*0.7);
      nibLenEff = nibLen * (0.6 + pressure*0.6);
    }
    return {color, opacity, nibLen:nibLenEff, nibThick, angleDeg, spacing, smoothing, jitter};
  }

  function lerp(a,b,t){ return a+(b-a)*t; }
  function dist(ax,ay,bx,by){ const dx=bx-ax, dy=by-ay; return Math.hypot(dx,dy); }

  function stamp(x,y, settings){
    const {nibLen, nibThick, angleDeg, color, opacity} = settings;
    const ang = angleDeg*Math.PI/180;
    ctx.save();
    ctx.translate(x,y);
    ctx.rotate(ang);
    ctx.globalAlpha = opacity;
    ctx.fillStyle = color;
    ctx.fillRect(-nibLen/2, -nibThick/2, nibLen, nibThick);
    ctx.restore();
  }

  function drawSegment(a,b, evt){
    const s = getSettings(evt);
    const step = Math.max(0.1, s.spacing);
    let d = dist(a.x,a.y,b.x,b.y) + carry;
    if(d < step){ carry = d; return; }
    const steps = Math.floor(d / step);
    for(let i=1; i<=steps; i++){
      const t = (i/steps);
      const x = lerp(a.x, b.x, t);
      const y = lerp(a.y, b.y, t);
      const j = s.jitter ? (Math.random()*2-1)*s.jitter : 0;
      stamp(x + j, y + j, s);
    }
    carry = d - steps*step;
  }

  function toCanvasCoords(e){
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    return { x: (e.clientX - rect.left)*scaleX, y: (e.clientY - rect.top)*scaleY };
  }

  // -------- Bezier helpers --------
  function clearOverlay(){ octx.clearRect(0,0,overlay.width, overlay.height); }

  function drawBezierPreview(){
    clearOverlay();
    if(tool!=='bezier') return;
    const pts = [...bezierPts];
    if(mousePos) pts.push(mousePos);
    octx.save();
    octx.lineWidth = 1;
    octx.strokeStyle = 'rgba(0,0,0,0.9)';
    octx.fillStyle = 'rgba(0,0,0,0.9)';
    if(pts.length>=2){
      octx.beginPath();
      octx.moveTo(pts[0].x, pts[0].y);
      if(pts.length===2){
        octx.lineTo(pts[1].x, pts[1].y);
      } else if(pts.length===3){
        octx.quadraticCurveTo(pts[1].x, pts[1].y, pts[2].x, pts[2].y);
      } else if(pts.length>=4){
        octx.bezierCurveTo(pts[1].x, pts[1].y, pts[2].x, pts[2].y, pts[3].x, pts[3].y);
      }
      octx.stroke();
    }
    for(const p of bezierPts){ drawHandle(p.x,p.y); }
    if(mousePos) drawHandle(mousePos.x, mousePos.y, true);
    octx.restore();
  }

  function drawHandle(x,y, ghost=false){
    octx.beginPath();
    octx.arc(x,y,3,0,Math.PI*2);
    octx[ghost?'stroke':'fill']();
  }

  function cubicAt(p0,p1,p2,p3,t){
    const it=1-t;
    const x = it*it*it*p0.x + 3*it*it*t*p1.x + 3*it*t*t*p2.x + t*t*t*p3.x;
    const y = it*it*it*p0.y + 3*it*it*t*p1.y + 3*it*t*t*p2.y + t*t*t*p3.y;
    return {x,y};
  }
  function quadAt(p0,p1,p2,t){
    const it=1-t;
    const x = it*it*p0.x + 2*it*t*p1.x + t*t*p2.x;
    const y = it*it*p0.y + 2*it*t*p1.y + t*t*p2.y;
    return {x,y};
  }

  function approxLenCubic(p0,p1,p2,p3){
    let len=0, prev=p0, steps=64;
    for(let i=1;i<=steps;i++){
      const t=i/steps; const p=cubicAt(p0,p1,p2,p3,t); len+=dist(prev.x,prev.y,p.x,p.y); prev=p;
    }
    return len;
  }
  function approxLenQuad(p0,p1,p2){
    let len=0, prev=p0, steps=48;
    for(let i=1;i<=steps;i++){
      const t=i/steps; const p=quadAt(p0,p1,p2,t); len+=dist(prev.x,prev.y,p.x,p.y); prev=p;
    }
    return len;
  }

  function stampAlongCurve(getPoint, approxLen, evt){
    const s = getSettings(evt);
    const step = Math.max(0.1, s.spacing);
    const L = approxLen();
    const n = Math.max(2, Math.floor(L/step));
    for(let i=0;i<=n;i++){
      const t = i/n;
      const p = getPoint(t);
      const j = s.jitter ? (Math.random()*2-1)*s.jitter : 0;
      stamp(p.x + j, p.y + j, s);
    }
  }

  function handleBezierClick(pt, e){
    bezierPts.push(pt);
    drawBezierPreview();
    if(bezierPts.length===4){
      pushUndo();
      stampAlongCurve(
        t=>cubicAt(bezierPts[0],bezierPts[1],bezierPts[2],bezierPts[3],t),
        ()=>approxLenCubic(bezierPts[0],bezierPts[1],bezierPts[2],bezierPts[3]),
        e
      );
      bezierPts.length = 0; // reset
      clearOverlay();
    }
  }

  function cancelBezier(){ bezierPts.length=0; clearOverlay(); }

  // -------- Freehand pen/eraser --------
  function beginStroke(e){
    drawing = true; last = toCanvasCoords(e); carry = 0;
    ctx.save();
    if(tool==='eraser') ctx.globalCompositeOperation = 'destination-out';
    else ctx.globalCompositeOperation = 'source-over';
    pushUndo();
    drawSegment(last, last, e); // initial tap
  }
  function moveStroke(e){
    if(tool==='bezier'){
      mousePos = toCanvasCoords(e);
      drawBezierPreview();
      updateReadout(e);
      return;
    }
    if(!drawing) return;
    const p = toCanvasCoords(e);
    const sm = parseFloat(inputs.smoothing.value);
    if(sm>0 && last){
      const alpha = Math.min(0.9, sm/20);
      p.x = last.x + (p.x - last.x)*(1-alpha);
      p.y = last.y + (p.y - last.y)*(1-alpha);
    }
    drawSegment(last, p, e);
    last = p;
  }
  function endStroke(){ drawing = false; last = null; carry = 0; ctx.restore(); }

  function updateReadout(e){
    const s = getSettings(e||{});
    const extra = (tool==='bezier'?` | Curve pts: ${bezierPts.length}`:'');
    readout.textContent = `Tool: ${tool}  |  Angle: ${s.angleDeg.toFixed(0)}¬∞  |  Width√óThick: ${s.nibLen.toFixed(1)}√ó${s.nibThick.toFixed(1)}  |  Spacing: ${s.spacing}  |  Opacity: ${(s.opacity*100)|0}%${extra}`;
  }

  // Events
  canvas.addEventListener('pointerdown', e=>{
    canvas.setPointerCapture(e.pointerId);
    if(tool==='bezier'){
      handleBezierClick(toCanvasCoords(e), e);
      updateReadout(e);
    } else {
      beginStroke(e); updateReadout(e);
    }
  });
  canvas.addEventListener('pointermove', e=>{ moveStroke(e); });
  window.addEventListener('pointerup', e=>{ if(drawing) endStroke(e); updateReadout(e); });

  // UI changes
  Object.values(inputs).forEach(el=>{
    if(!el) return;
    const ev = (el.tagName==='SELECT' || el.type==='checkbox') ? 'change':'input';
    el.addEventListener(ev, ()=>{ uiSync(); updateReadout(); drawBezierPreview(); });
  });

  inputs.resizeBtn.addEventListener('click', ()=>{
    setCanvasSize(parseInt(inputs.cw.value,10), parseInt(inputs.ch.value,10), true);
  });

  // Tool buttons
  buttons.pen.addEventListener('click', ()=>{ tool='pen'; cancelBezier(); uiSync(); });
  buttons.eraser.addEventListener('click', ()=>{ tool='eraser'; cancelBezier(); uiSync(); });
  buttons.bezier.addEventListener('click', ()=>{ tool='bezier'; cancelBezier(); uiSync(); });
  buttons.undo.addEventListener('click', undo);
  buttons.redo.addEventListener('click', redo);
  buttons.clear.addEventListener('click', ()=>{ pushUndo(); ctx.clearRect(0,0,canvas.width,canvas.height); setPaper(); clearOverlay(); cancelBezier(); });
  buttons.save.addEventListener('click', ()=>{
    const link = document.createElement('a');
    link.download = 'chisel-pen.png';
    link.href = canvas.toDataURL('image/png');
    link.click();
  });

  // Keyboard shortcuts
  window.addEventListener('keydown', e=>{
    if(e.key==='p' || e.key==='P'){ tool='pen'; cancelBezier(); uiSync(); }
    if(e.key==='e' || e.key==='E'){ tool='eraser'; cancelBezier(); uiSync(); }
    if(e.key==='b' || e.key==='B'){ tool='bezier'; cancelBezier(); uiSync(); }
    if(e.key==='s' || e.key==='S'){ e.preventDefault(); buttons.save.click(); }
    if(e.key==='c' || e.key==='C'){ buttons.clear.click(); }
    if(e.key==='['){ inputs.angle.value = Math.max(0, parseInt(inputs.angle.value,10)-1); uiSync(); drawBezierPreview(); }
    if(e.key===']'){ inputs.angle.value = Math.min(180, parseInt(inputs.angle.value,10)+1); uiSync(); drawBezierPreview(); }
    if((e.ctrlKey||e.metaKey) && !e.shiftKey && (e.key==='z' || e.key==='Z')){ e.preventDefault(); undo(); }
    if((e.ctrlKey||e.metaKey) && (e.shiftKey) && (e.key==='z' || e.key==='Z')){ e.preventDefault(); redo(); }
    if(e.key==='Escape'){ cancelBezier(); uiSync(); }
  });

  // Init
  setCanvasSize(parseInt(inputs.cw.value,10), parseInt(inputs.ch.value,10), false);
  uiSync();
  pushUndo();
  updateReadout();

  // Auto-run diagnostics once on load to act as a simple test case
  runDiagnostics();
});
</script>
</body>
</html>
