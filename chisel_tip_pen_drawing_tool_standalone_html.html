<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Chisel‚ÄëTip Pen ‚Äî Standalone</title>
<style>
  :root{
    --bg:#111417; --panel:#1b2026; --panel-2:#151a1f; --text:#e7edf3; --muted:#9db0c4; --accent:#5bb6ff;
    --btn:#222933; --btn-hover:#2a3340; --danger:#ff6b6b; --ok:#58d68d; --grid:#1f2530;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0; background:var(--bg); color:var(--text); font:14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;}
  .app{display:grid; grid-template-columns: 320px 1fr; grid-template-rows:auto 1fr; height:100vh}
  header{grid-column:1/3; padding:10px 12px; display:flex; gap:10px; align-items:center; background:linear-gradient(180deg,var(--panel),var(--panel-2)); border-bottom:1px solid #0d1117; position:sticky; top:0; z-index:3}
  header h1{font-size:14px; margin:0; letter-spacing:.02em; color:var(--muted)}
  .toolbar{display:flex; gap:8px; flex-wrap:wrap; align-items:center}
  .side{padding:12px; background:var(--panel); border-right:1px solid #0d1117; overflow:auto}
  .group{background:var(--panel-2); border:1px solid #0d1117; border-radius:12px; padding:10px; margin-bottom:10px}
  .group h3{margin:0 0 8px; font-size:12px; color:var(--muted); font-weight:600; text-transform:uppercase; letter-spacing:.08em}
  label{display:grid; grid-template-columns: 1fr auto; gap:8px; align-items:center; margin:6px 0}
  input[type="range"]{width:180px}
  input[type="number"]{width:72px; background:#0f141a; color:var(--text); border:1px solid #0d1117; padding:4px 6px; border-radius:8px}
  input[type="checkbox"]{transform:translateY(1px)}
  .row{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
  .btn{border:1px solid #0d1117; background:var(--btn); color:var(--text); padding:8px 10px; border-radius:10px; cursor:pointer}
  .btn:hover{background:var(--btn-hover)}
  .btn.eraser{border-color:#2b2b2b}
  .btn.danger{background:#2a1b1b; border-color:#3b2222}
  .btn.primary{outline:1px solid #2b3642}
  .swatch{width:30px; height:30px; border-radius:8px; border:1px solid #0d1117; overflow:hidden}
  #canvasWrap{position:relative; background:var(--bg)}
  canvas{display:block; width:100%; height:100%; background:transparent; cursor: crosshair}
  .overlay{position:absolute; inset:0; pointer-events:none}
  .grid{position:absolute; inset:0; background-size: 32px 32px, 8px 8px; background-image:
        linear-gradient(var(--grid) 1px, transparent 1px),
        linear-gradient(90deg, var(--grid) 1px, transparent 1px);
        pointer-events:none; z-index:0; opacity:.6}
  .readout{position:absolute; right:10px; bottom:10px; background:rgba(0,0,0,.5); padding:6px 8px; border-radius:8px; font:12px/1.2 ui-monospace, SFMono-Regular, Menlo, monospace; color:#cde}
  .kbd{font:12px/1 ui-monospace, SFMono-Regular, Menlo, monospace; background:#10151b; border:1px solid #0d1117; padding:2px 5px; border-radius:6px}
  .help{color:var(--muted); font-size:12px}
</style>
</head>
<body>
  <div class="app">
    <header>
      <h1>Chisel‚ÄëTip Pen</h1>
      <div class="toolbar" id="toolbar">
        <button class="btn primary" id="penBtn" title="Pen (P)">‚úíÔ∏è Pen</button>
        <button class="btn eraser" id="eraserBtn" title="Eraser (E)">ü©π Eraser</button>
        <button class="btn" id="bezierBtn" title="Bezier Curves (B)">‚û∞ Bezier</button>
        <button class="btn" id="undoBtn" title="Undo (Ctrl/Cmd+Z)">‚Ü∂ Undo</button>
        <button class="btn" id="redoBtn" title="Redo (Ctrl/Cmd+Shift+Z)">‚Ü∑ Redo</button>
        <button class="btn" id="clearBtn" title="Clear (C)">üóë Clear</button>
        <button class="btn" id="saveBtn" title="Save PNG (S)">üíæ Save</button>
      </div>
    </header>

    <aside class="side">
      <div class="group">
        <h3>Nib</h3>
        <div class="row" style="gap:12px">
          <div>
            <div class="help">Color</div>
            <input id="color" type="color" value="#000000" />
          </div>
          <div>
            <div class="help">Opacity</div>
            <input id="opacity" type="range" min="0" max="1" step="0.01" value="1" />
          </div>
          <div class="swatch" id="swatch"></div>
        </div>
        <label>Width (broad) <input id="nibLen" type="range" min="4" max="200" step="1" value="50"></label>
        <label>Thickness (edge) <input id="nibThick" type="range" min="1" max="60" step="1" value="12"></label>
        <label>Angle <input id="angle" type="range" min="0" max="180" step="1" value="35"></label>
        <div class="help">Tip: change angle with <span class="kbd">[</span> and <span class="kbd">]</span></div>
      </div>

      <div class="group">
        <h3>Stroke</h3>
        <label>Spacing <input id="spacing" type="range" min="0.5" max="20" step="0.5" value="3"></label>
        <label>Smoothing (px) <input id="smoothing" type="range" min="0" max="20" step="1" value="2"></label>
        <label>Pressure affects
          <select id="pressureMode">
            <option value="off">Off</option>
            <option value="thick">Thickness</option>
            <option value="both">Both axes</option>
          </select>
        </label>
        <label>Jitter (px) <input id="jitter" type="range" min="0" max="3" step="0.1" value="0"></label>
      </div>

      <div class="group">
        <h3>Canvas</h3>
        <label>Size W √ó H
          <div class="row">
            <input id="cw" type="number" min="256" max="4096" step="1" value="1600">
            <input id="ch" type="number" min="256" max="4096" step="1" value="900">
            <button class="btn" id="resizeBtn">Resize</button>
          </div>
        </label>
        <label>Paper <select id="paper">
          <option value="transparent">Transparent</option>
          <option value="ivory" selected>Ivory</option>
          <option value="white">White</option>
          <option value="charcoal">Charcoal</option>
        </select></label>
        <label><span>Show grid</span> <input id="grid" type="checkbox" checked></label>
        <label><span>Dark UI</span> <input id="dark" type="checkbox" checked></label>
      </div>

      <div class="group">
        <h3>Shortcuts</h3>
        <div class="help">
          <p><span class="kbd">P</span> Pen ¬∑ <span class="kbd">E</span> Eraser ¬∑ <span class="kbd">B</span> Bezier ¬∑ <span class="kbd">[</span>/<span class="kbd">]</span> Angle ¬∑ <span class="kbd">C</span> Clear ¬∑ <span class="kbd">S</span> Save ¬∑ <span class="kbd">Z</span> Undo ¬∑ <span class="kbd">Shift+Z</span> Redo ¬∑ <span class="kbd">Esc</span> Cancel curve</p>
        </div>
      </div>
    </aside>

    <main id="canvasWrap">
      <div class="grid" id="gridLayer"></div>
      <canvas id="canvas"></canvas>
      <canvas id="overlay" class="overlay"></canvas>
      <div class="readout" id="readout"></div>
    </main>
  </div>

<script>
(function(){
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const overlay = document.getElementById('overlay');
  const octx = overlay.getContext('2d');
  const gridLayer = document.getElementById('gridLayer');
  const readout = document.getElementById('readout');
  const swatch = document.getElementById('swatch');
  const inputs = {
    color: document.getElementById('color'),
    opacity: document.getElementById('opacity'),
    nibLen: document.getElementById('nibLen'),
    nibThick: document.getElementById('nibThick'),
    angle: document.getElementById('angle'),
    spacing: document.getElementById('spacing'),
    smoothing: document.getElementById('smoothing'),
    jitter: document.getElementById('jitter'),
    pressureMode: document.getElementById('pressureMode'),
    cw: document.getElementById('cw'),
    ch: document.getElementById('ch'),
    resizeBtn: document.getElementById('resizeBtn'),
    paper: document.getElementById('paper'),
    grid: document.getElementById('grid'),
    dark: document.getElementById('dark')
  };
  const buttons = {
    pen: document.getElementById('penBtn'),
    eraser: document.getElementById('eraserBtn'),
    bezier: document.getElementById('bezierBtn'),
    undo: document.getElementById('undoBtn'),
    redo: document.getElementById('redoBtn'),
    clear: document.getElementById('clearBtn'),
    save: document.getElementById('saveBtn')
  };

  let tool = 'pen';
  let drawing = false;
  let last = null; // {x,y}
  let carry = 0;   // leftover distance for spacing
  let undoStack = [], redoStack = [];
  const UNDO_LIMIT = 40;

  // Bezier state
  let bezierPts = []; // stores clicked points in canvas coords
  let mousePos = null;

  function setCanvasSize(w,h, preserve=true){
    w = Math.max(1, Math.floor(w));
    h = Math.max(1, Math.floor(h));
    let snapshot = null;
    if(preserve){ snapshot = canvas.toDataURL('image/png'); }
    canvas.width = w; canvas.height = h;
    overlay.width = w; overlay.height = h;
    fitCanvasToContainer();
    setPaper();
    clearOverlay();
    if(preserve && snapshot){
      const img = new Image();
      img.onload = ()=>{ ctx.drawImage(img,0,0); pushUndo(); };
      img.src = snapshot;
    } else {
      pushUndo();
    }
  }

  function fitCanvasToContainer(){
    // CSS handles scaling; overlay matches canvas size via width/height attributes.
  }

  function setPaper(){
    const p = inputs.paper.value;
    let color = 'transparent';
    if(p==='ivory') color = '#f5f1e6';
    if(p==='white') color = '#ffffff';
    if(p==='charcoal') color = '#0f1115';
    // redraw background by compositing under existing content
    const img = new Image();
    img.onload = ()=>{
      const tmp = document.createElement('canvas');
      tmp.width = canvas.width; tmp.height = canvas.height;
      const tctx = tmp.getContext('2d');
      if(color!=='transparent'){
        tctx.fillStyle = color; tctx.fillRect(0,0,tmp.width,tmp.height);
      }
      tctx.drawImage(canvas,0,0);
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.drawImage(tmp,0,0);
    };
    img.src = canvas.toDataURL();
  }

  function uiSync(){
    const c = inputs.color.value;
    const a = parseFloat(inputs.opacity.value);
    swatch.style.background = c;
    swatch.style.opacity = a;
    document.documentElement.style.setProperty('--grid', inputs.dark.checked? '#1f2530' : '#d8dbe2');
    document.body.style.setProperty('--bg', inputs.dark.checked? '#111417':'#f3f5f7');
    document.body.style.setProperty('--panel', inputs.dark.checked? '#1b2026':'#ffffff');
    document.body.style.setProperty('--panel-2', inputs.dark.checked? '#151a1f':'#f7f9fb');
    document.body.style.setProperty('--text', inputs.dark.checked? '#e7edf3':'#0a0f14');
    document.body.style.setProperty('--muted', inputs.dark.checked? '#9db0c4':'#5b6b7c');
    gridLayer.style.display = inputs.grid.checked? 'block':'none';
    buttons.pen.classList.toggle('primary', tool==='pen');
    buttons.eraser.classList.toggle('primary', tool==='eraser');
    buttons.bezier.classList.toggle('primary', tool==='bezier');
  }

  function pushUndo(){
    try {
      undoStack.push(canvas.toDataURL('image/png'));
      if(undoStack.length>UNDO_LIMIT) undoStack.shift();
      redoStack.length = 0;
    } catch(e){ /* ignore */ }
  }

  function undo(){
    if(undoStack.length<2) return; // keep at least current state
    const current = undoStack.pop();
    redoStack.push(current);
    const dataURL = undoStack[undoStack.length-1];
    const img = new Image();
    img.onload = ()=>{ ctx.clearRect(0,0,canvas.width,canvas.height); ctx.drawImage(img,0,0); };
    img.src = dataURL;
  }
  function redo(){
    if(!redoStack.length) return;
    const dataURL = redoStack.pop();
    undoStack.push(dataURL);
    const img = new Image();
    img.onload = ()=>{ ctx.clearRect(0,0,canvas.width,canvas.height); ctx.drawImage(img,0,0); };
    img.src = dataURL;
  }

  function getSettings(evt){
    const color = inputs.color.value;
    const opacity = parseFloat(inputs.opacity.value);
    const nibLen = parseFloat(inputs.nibLen.value);
    const nibThickBase = parseFloat(inputs.nibThick.value);
    const angleDeg = parseFloat(inputs.angle.value);
    const spacing = Math.max(0.1, parseFloat(inputs.spacing.value));
    const smoothing = parseFloat(inputs.smoothing.value);
    const jitter = parseFloat(inputs.jitter.value);
    const pressure = evt && 'pressure' in evt ? Math.max(0.0, Math.min(1.0, evt.pressure || 0)) : 0.5;
    const pmode = inputs.pressureMode.value;
    let nibThick = nibThickBase;
    let nibLenEff = nibLen;
    if(pmode==='thick'){
      nibThick = nibThickBase * (0.3 + pressure*0.7);
    } else if(pmode==='both'){
      nibThick = nibThickBase * (0.3 + pressure*0.7);
      nibLenEff = nibLen * (0.6 + pressure*0.6);
    }
    return {color, opacity, nibLen:nibLenEff, nibThick, angleDeg, spacing, smoothing, jitter};
  }

  function lerp(a,b,t){ return a+(b-a)*t; }
  function dist(ax,ay,bx,by){ const dx=bx-ax, dy=by-ay; return Math.hypot(dx,dy); }

  function stamp(x,y, settings){
    const {nibLen, nibThick, angleDeg, color, opacity} = settings;
    const ang = angleDeg*Math.PI/180;
    ctx.save();
    ctx.translate(x,y);
    ctx.rotate(ang);
    ctx.globalAlpha = opacity;
    ctx.fillStyle = color;
    ctx.fillRect(-nibLen/2, -nibThick/2, nibLen, nibThick);
    ctx.restore();
  }

  function drawSegment(a,b, evt){
    const s = getSettings(evt);
    const step = Math.max(0.1, s.spacing);
    let d = dist(a.x,a.y,b.x,b.y) + carry;
    if(d < step){ carry = d; return; }
    const steps = Math.floor(d / step);
    for(let i=1; i<=steps; i++){
      const t = (i/steps);
      const x = lerp(a.x, b.x, t);
      const y = lerp(a.y, b.y, t);
      const j = s.jitter ? (Math.random()*2-1)*s.jitter : 0;
      stamp(x + j, y + j, s);
    }
    carry = d - steps*step;
  }

  function toCanvasCoords(e){
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    return { x: (e.clientX - rect.left)*scaleX, y: (e.clientY - rect.top)*scaleY };
  }

  // -------- Bezier helpers --------
  function clearOverlay(){ octx.clearRect(0,0,overlay.width, overlay.height); }

  function drawBezierPreview(){
    clearOverlay();
    if(tool!=='bezier') return;
    const pts = [...bezierPts];
    if(mousePos) pts.push(mousePos);
    octx.save();
    octx.lineWidth = 1;
    octx.strokeStyle = 'rgba(200,220,255,0.9)';
    octx.fillStyle = 'rgba(200,220,255,0.9)';
    // draw guideline
    if(pts.length>=2){
      octx.beginPath();
      octx.moveTo(pts[0].x, pts[0].y);
      if(pts.length===2){
        octx.lineTo(pts[1].x, pts[1].y);
      } else if(pts.length===3){
        // quadratic preview
        octx.quadraticCurveTo(pts[1].x, pts[1].y, pts[2].x, pts[2].y);
      } else if(pts.length>=4){
        octx.bezierCurveTo(pts[1].x, pts[1].y, pts[2].x, pts[2].y, pts[3].x, pts[3].y);
      }
      octx.stroke();
    }
    // draw points
    for(const p of bezierPts){ drawHandle(p.x,p.y); }
    if(mousePos) drawHandle(mousePos.x, mousePos.y, true);
    octx.restore();
  }

  function drawHandle(x,y, ghost=false){
    octx.beginPath();
    octx.arc(x,y,3,0,Math.PI*2);
    octx[ghost?'stroke':'fill']();
  }

  function cubicAt(p0,p1,p2,p3,t){
    const it=1-t;
    const x = it*it*it*p0.x + 3*it*it*t*p1.x + 3*it*t*t*p2.x + t*t*t*p3.x;
    const y = it*it*it*p0.y + 3*it*it*t*p1.y + 3*it*t*t*p2.y + t*t*t*p3.y;
    return {x,y};
  }
  function quadAt(p0,p1,p2,t){
    const it=1-t;
    const x = it*it*p0.x + 2*it*t*p1.x + t*t*p2.x;
    const y = it*it*p0.y + 2*it*t*p1.y + t*t*p2.y;
    return {x,y};
  }

  function approxLenCubic(p0,p1,p2,p3){
    // polyline approx
    let len=0, prev=p0, steps=64;
    for(let i=1;i<=steps;i++){
      const t=i/steps; const p=cubicAt(p0,p1,p2,p3,t); len+=dist(prev.x,prev.y,p.x,p.y); prev=p;
    }
    return len;
  }
  function approxLenQuad(p0,p1,p2){
    let len=0, prev=p0, steps=48;
    for(let i=1;i<=steps;i++){
      const t=i/steps; const p=quadAt(p0,p1,p2,t); len+=dist(prev.x,prev.y,p.x,p.y); prev=p;
    }
    return len;
  }

  function stampAlongCurve(getPoint, approxLen, evt){
    const s = getSettings(evt);
    const step = Math.max(0.1, s.spacing);
    const L = approxLen();
    const n = Math.max(2, Math.floor(L/step));
    for(let i=0;i<=n;i++){
      const t = i/n;
      const p = getPoint(t);
      const j = s.jitter ? (Math.random()*2-1)*s.jitter : 0;
      stamp(p.x + j, p.y + j, s);
    }
  }

  function handleBezierClick(pt, e){
    bezierPts.push(pt);
    drawBezierPreview();
    if(bezierPts.length===4){
      // Draw cubic
      pushUndo();
      stampAlongCurve(
        t=>cubicAt(bezierPts[0],bezierPts[1],bezierPts[2],bezierPts[3],t),
        ()=>approxLenCubic(bezierPts[0],bezierPts[1],bezierPts[2],bezierPts[3]),
        e
      );
      bezierPts.length = 0; // reset
      clearOverlay();
    }
  }

  function cancelBezier(){ bezierPts.length=0; clearOverlay(); }

  // -------- Freehand pen/eraser --------
  function beginStroke(e){
    drawing = true; last = toCanvasCoords(e); carry = 0;
    ctx.save();
    if(tool==='eraser') ctx.globalCompositeOperation = 'destination-out';
    else ctx.globalCompositeOperation = 'source-over';
    pushUndo();
    // initial stamp for taps
    drawSegment(last, last, e);
  }
  function moveStroke(e){
    if(tool==='bezier'){
      mousePos = toCanvasCoords(e);
      drawBezierPreview();
      updateReadout(e);
      return;
    }
    if(!drawing) return;
    const p = toCanvasCoords(e);
    // Optional smoothing via simple lerp toward target
    const sm = parseFloat(inputs.smoothing.value);
    if(sm>0 && last){
      const alpha = Math.min(0.9, sm/20);
      p.x = last.x + (p.x - last.x)*(1-alpha);
      p.y = last.y + (p.y - last.y)*(1-alpha);
    }
    drawSegment(last, p, e);
    last = p;
  }
  function endStroke(){ drawing = false; last = null; carry = 0; ctx.restore(); }

  function updateReadout(e){
    const s = getSettings(e||{});
    const extra = (tool==='bezier'?` | Curve pts: ${bezierPts.length}`:'');
    readout.textContent = `Tool: ${tool}  |  Angle: ${s.angleDeg.toFixed(0)}¬∞  |  Width√óThick: ${s.nibLen.toFixed(1)}√ó${s.nibThick.toFixed(1)}  |  Spacing: ${s.spacing}  |  Opacity: ${(s.opacity*100)|0}%${extra}`;
  }

  // Events
  canvas.addEventListener('pointerdown', e=>{
    canvas.setPointerCapture(e.pointerId);
    if(tool==='bezier'){
      handleBezierClick(toCanvasCoords(e), e);
      updateReadout(e);
    } else {
      beginStroke(e); updateReadout(e);
    }
  });
  canvas.addEventListener('pointermove', e=>{ moveStroke(e); });
  window.addEventListener('pointerup', e=>{ if(drawing) endStroke(e); updateReadout(e); });

  // UI changes
  Object.values(inputs).forEach(el=>{
    if(!el) return;
    const ev = (el.tagName==='SELECT' || el.type==='checkbox') ? 'change':'input';
    el.addEventListener(ev, ()=>{ uiSync(); updateReadout(); drawBezierPreview(); });
  });

  inputs.resizeBtn.addEventListener('click', ()=>{
    setCanvasSize(parseInt(inputs.cw.value,10), parseInt(inputs.ch.value,10), true);
  });

  // Tool buttons
  buttons.pen.addEventListener('click', ()=>{ tool='pen'; cancelBezier(); uiSync(); });
  buttons.eraser.addEventListener('click', ()=>{ tool='eraser'; cancelBezier(); uiSync(); });
  buttons.bezier.addEventListener('click', ()=>{ tool='bezier'; cancelBezier(); uiSync(); });
  buttons.undo.addEventListener('click', undo);
  buttons.redo.addEventListener('click', redo);
  buttons.clear.addEventListener('click', ()=>{ pushUndo(); ctx.clearRect(0,0,canvas.width,canvas.height); setPaper(); clearOverlay(); cancelBezier(); });
  buttons.save.addEventListener('click', ()=>{
    const link = document.createElement('a');
    link.download = 'chisel-pen.png';
    link.href = canvas.toDataURL('image/png');
    link.click();
  });

  // Keyboard shortcuts
  window.addEventListener('keydown', e=>{
    if(e.key==='p' || e.key==='P'){ tool='pen'; cancelBezier(); uiSync(); }
    if(e.key==='e' || e.key==='E'){ tool='eraser'; cancelBezier(); uiSync(); }
    if(e.key==='b' || e.key==='B'){ tool='bezier'; cancelBezier(); uiSync(); }
    if(e.key==='s' || e.key==='S'){ e.preventDefault(); buttons.save.click(); }
    if(e.key==='c' || e.key==='C'){ buttons.clear.click(); }
    if(e.key==='['){ inputs.angle.value = Math.max(0, parseInt(inputs.angle.value,10)-1); uiSync(); drawBezierPreview(); }
    if(e.key===']'){ inputs.angle.value = Math.min(180, parseInt(inputs.angle.value,10)+1); uiSync(); drawBezierPreview(); }
    if((e.ctrlKey||e.metaKey) && !e.shiftKey && (e.key==='z' || e.key==='Z')){ e.preventDefault(); undo(); }
    if((e.ctrlKey||e.metaKey) && (e.shiftKey) && (e.key==='z' || e.key==='Z')){ e.preventDefault(); redo(); }
    if(e.key==='Escape'){ cancelBezier(); uiSync(); }
  });

  // Init
  setCanvasSize(parseInt(inputs.cw.value,10), parseInt(inputs.ch.value,10), false);
  uiSync();
  pushUndo();
  updateReadout();
})();
</script>
</body>
</html>
