<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Particle Tree Generator</title>
  <style>
    html, body { margin: 0; padding: 0; background: white; color: black; font-family: monospace; overflow: hidden; }
    canvas { display: block; background: white; border: 2px solid black; }
    .ui { position: absolute; top: 10px; left: 10px; background: white; border: 2px solid black; padding: 10px; z-index: 10; }
    label, button { display: block; margin-bottom: 6px; }
    input[type=range], input[type=checkbox] { width: 100%; }
  </style>
</head>
<body>
  <canvas id="treeCanvas"></canvas>
  <div class="ui">
    <label>Curviness Threshold: <input type="range" id="curviness" min="0.1" max="3.14" step="0.01" value="1.57"></label>
    <label>Angle Range: <input type="range" id="angleRange" min="0" max="1" step="0.01" value="0.2"></label>
    <label>Step Size: <input type="range" id="stepSize" min="0.5" max="10" step="0.1" value="2"></label>
    <label>Branching Angle: <input type="range" id="branchAngle" min="0" max="2" step="0.01" value="0.5"></label>
    <label>Max Depth: <input type="range" id="maxDepth" min="1" max="12" step="1" value="8"></label>
    <label>Particle Skip Rate: <input type="range" id="skipRate" min="0" max="1" step="0.01" value="0.01"></label>
    <label>Branch Probability: <input type="range" id="branchProb" min="0" max="1" step="0.01" value="1"></label>
    <label>Max Branch Length: <input type="range" id="maxLength" min="10" max="1000" step="10" value="300"></label>
    <label>Particle Lifespan: <input type="range" id="lifespan" min="10" max="1000" step="1" value="200"></label>
    <label><input type="checkbox" id="avoidance" checked> Avoid overlapping lines</label>
    <button onclick="restart()">Restart</button>
    <button onclick="exportSVG()">Export as SVG</button>
  </div>

  <script>
    const canvas = document.getElementById('treeCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    let particles = [], svgPaths = [], drawnPoints = new Set();
    let offsetX = 0, offsetY = 0, scale = 1;
    let isDragging = false, lastX = 0, lastY = 0;

    canvas.addEventListener('mousedown', e => { isDragging = true; lastX = e.clientX; lastY = e.clientY; });
    canvas.addEventListener('mouseup', () => isDragging = false);
    canvas.addEventListener('mousemove', e => {
      if (isDragging) {
        offsetX += (e.clientX - lastX) / scale;
        offsetY += (e.clientY - lastY) / scale;
        lastX = e.clientX;
        lastY = e.clientY;
        redrawAll();
      }
    });
    canvas.addEventListener('wheel', e => {
      const zoomFactor = 1.1;
      const mouseX = (e.clientX - canvas.offsetLeft) / scale - offsetX;
      const mouseY = (e.clientY - canvas.offsetTop) / scale - offsetY;
      if (e.deltaY < 0) scale *= zoomFactor;
      else scale /= zoomFactor;
      offsetX = (e.clientX / scale) - mouseX;
      offsetY = (e.clientY / scale) - mouseY;
      e.preventDefault();
      redrawAll();
    }, { passive: false });

    class Particle {
      constructor(x, y, angle, depth = 0, lifespan = 200) {
        this.x = x; this.y = y; this.angle = angle; this.depth = depth;
        this.curviness = 0; this.length = 0; this.age = 0; this.lifespan = lifespan;
      }

      update(config) {
        if (this.age++ > this.lifespan || this.length > config.maxLength) return;
        const deltaAngle = (Math.random() - 0.5) * config.angleRange;
        this.angle += deltaAngle;
        const dx = Math.cos(this.angle) * config.stepSize;
        const dy = Math.sin(this.angle) * config.stepSize;
        const nx = this.x + dx, ny = this.y + dy;
        const key = `${Math.round(nx)},${Math.round(ny)}`;
        if (config.avoidance && drawnPoints.has(key)) return;
        drawnPoints.add(key);

        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(nx, ny);
        ctx.stroke();

        svgPaths.push(`<line x1="${this.x.toFixed(2)}" y1="${this.y.toFixed(2)}" x2="${nx.toFixed(2)}" y2="${ny.toFixed(2)}" stroke="black" stroke-width="1" />`);

        this.curviness += Math.abs(deltaAngle);
        this.length += Math.hypot(dx, dy);
        this.x = nx; this.y = ny;

        if (this.curviness > config.curvinessThreshold && this.depth < config.maxDepth) {
          this.curviness = 0;
          if (Math.random() < config.branchProb) particles.push(new Particle(this.x, this.y, this.angle - config.branchAngle, this.depth + 1, this.lifespan * 0.9));
          if (Math.random() < config.branchProb) particles.push(new Particle(this.x, this.y, this.angle + config.branchAngle, this.depth + 1, this.lifespan * 0.9));
        }
      }
    }

    function getConfig() {
      return {
        curvinessThreshold: parseFloat(curviness.value), angleRange: parseFloat(angleRange.value),
        stepSize: parseFloat(stepSize.value), branchAngle: parseFloat(branchAngle.value),
        maxDepth: parseInt(maxDepth.value), skipRate: parseFloat(skipRate.value),
        branchProb: parseFloat(branchProb.value), maxLength: parseFloat(maxLength.value),
        lifespan: parseInt(lifespan.value), avoidance: avoidance.checked
      };
    }

    function animate() {
      const config = getConfig();
      ctx.setTransform(scale, 0, 0, scale, offsetX * scale, offsetY * scale);
      for (let i = 0; i < particles.length; i++) {
        if (Math.random() > config.skipRate) particles[i].update(config);
      }
      requestAnimationFrame(animate);
    }

    function redrawAll() {
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.setTransform(scale, 0, 0, scale, offsetX * scale, offsetY * scale);
      ctx.strokeStyle = 'black';
      ctx.lineWidth = 1;
      svgPaths.forEach(path => {
        const m = path.match(/x1="(.*?)" y1="(.*?)" x2="(.*?)" y2="(.*?)"/);
        if (m) {
          ctx.beginPath();
          ctx.moveTo(parseFloat(m[1]), parseFloat(m[2]));
          ctx.lineTo(parseFloat(m[3]), parseFloat(m[4]));
          ctx.stroke();
        }
      });
    }

    function restart(x = canvas.width / 2, y = canvas.height) {
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      svgPaths = [];
      drawnPoints = new Set();
      offsetX = 0;
      offsetY = 0;
      scale = 1;
      const lifespan = parseInt(document.getElementById('lifespan').value);
      particles = [new Particle(x, y, -Math.PI / 2, 0, lifespan)];
    }

    function exportSVG() {
      const width = canvas.width, height = canvas.height;
      const svgContent = `<?xml version="1.0" standalone="no"?>\n<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}">\n` +
                         svgPaths.join("\n") + "\n</svg>";
      const blob = new Blob([svgContent], { type: 'image/svg+xml' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'particle_tree.svg';
      a.click();
      URL.revokeObjectURL(url);
    }

    canvas.addEventListener('click', e => restart((e.offsetX - offsetX * scale) / scale, (e.offsetY - offsetY * scale) / scale));
    ctx.strokeStyle = 'black';
    ctx.lineWidth = 1;
    restart();
    animate();
  </script>
</body>
</html>
