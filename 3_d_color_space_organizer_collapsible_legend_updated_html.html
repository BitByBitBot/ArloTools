<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>3D Color‑Space Organizer</title>
  <style>
   :root { --bg:#ffffff; --fg:#000000; --muted:#666666; --accent:#0077ff; --panel:#f9f9f9; }
*{box-sizing:border-box}
body{margin:0;display:flex;flex-direction:column;height:100vh;background:var(--bg);color:var(--fg);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Inter,Roboto,Arial}
header{position:sticky;top:0;z-index:5;backdrop-filter:blur(6px);background:rgba(255,255,255,0.9);border-bottom:1px solid #ddd}
.bar{display:grid;grid-template-columns:1fr auto auto auto auto;gap:.75rem;padding:.9rem 1rem;align-items:center}
.title{font-weight:700;letter-spacing:.2px}
.controls{display:flex;gap:.5rem;align-items:center;flex-wrap:wrap}
label{font-size:.85rem;color:var(--muted)}
input[type=number],select,input[type=file]{background:var(--panel);color:var(--fg);border:1px solid #ccc;border-radius:.4rem;padding:.4rem .6rem}
input[type=number]{width:6rem}
button{background:var(--accent);color:#fff;border:none;padding:.5rem .8rem;border-radius:.5rem;font-weight:600;cursor:pointer;box-shadow:0 2px 6px rgba(0,0,0,.15)}
button.secondary{background:#f0f0f0;color:var(--fg);border:1px solid #ccc;box-shadow:none}
.progress-wrap{height:.4rem;background:#eee;border-top:1px solid #ddd}
.progress{height:100%;width:0;background:linear-gradient(90deg,#0077ff,#66bbff);transition:width .15s ease}

main{flex:1;display:flex}
#view3d{flex:1;min-height:0;outline:1px solid #ddd}
  </style>
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <header>
    <div class="bar">
      <div class="title">3D Color‑Space Organizer</div>
      <div class="controls">
        <label>Images <input id="count" type="number" min="12" max="400" value="160"/></label>
        <label>Thumb px <input id="thumb" type="number" min="48" max="256" value="128"/></label>
        <label>Colorspace
          <select id="space">
            <option value="rgb" selected>RGB → (x=R, y=G, z=B)</option>
            <option value="hsv">HSV → (x=H, y=S, z=V)</option>
          </select>
        </label>
        <label>Upload<input id="upload" type="file" accept="image/*" multiple /></label>
        <button id="go">Load & Arrange</button>
        <button id="repack" class="secondary">Re‑pack</button>
      </div>
    </div>
    <div class="progress-wrap"><div class="progress" id="progress"></div></div>
  </header>

  <main>
    <div id="view3d"></div>
  </main>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    const view3d = document.getElementById('view3d');
    const countEl = document.getElementById('count');
    const thumbEl = document.getElementById('thumb');
    const spaceEl = document.getElementById('space');
    const goBtn = document.getElementById('go');
    const repackBtn = document.getElementById('repack');
    const progress = document.getElementById('progress');
    const uploadEl = document.getElementById('upload');

    let customFiles = [];
    uploadEl.addEventListener('change', () => {
      customFiles = Array.from(uploadEl.files);
    });

    function setProgress(f){ progress.style.width = `${Math.max(0, Math.min(1, f))*100}%`; }

    async function fetchPicsumList(n, size){
      const perPage = Math.min(100, n);
      const pages = Math.ceil(n / perPage);
      let out = [];
      for (let p=1; p<=pages; p++){
        const resp = await fetch(`https://picsum.photos/v2/list?page=${p}&limit=${perPage}`);
        const data = await resp.json();
        out = out.concat(data);
      }
      return out.slice(0,n).map(d=>({ id:d.id, url:`https://picsum.photos/id/${d.id}/${size}/${size}.jpg` }));
    }

    function loadImage(src){
      return new Promise((resolve,reject)=>{
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.decoding = 'async';
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.src = src;
      });
    }

    function rgb2hsv(r,g,b){
      r/=255; g/=255; b/=255;
      const max=Math.max(r,g,b), min=Math.min(r,g,b); const d=max-min;
      let h=0; if (d!==0){
        switch(max){ case r: h=((g-b)/d)%6; break; case g: h=(b-r)/d+2; break; case b: h=(r-g)/d+4; break; }
        h*=60; if(h<0) h+=360;
      }
      const s = max===0?0:d/max; const v=max; return [h/360, s, v];
    }

    function averageColor(img){
      const c = document.createElement('canvas'); const s = Math.min(thumbEl.value|0, 64);
      c.width=s; c.height=s; const ctx=c.getContext('2d');
      ctx.drawImage(img, 0,0,s,s); const { data } = ctx.getImageData(0,0,s,s);
      let r=0,g=0,b=0,n=0; for(let i=0;i<data.length;i+=4){ r+=data[i]; g+=data[i+1]; b+=data[i+2]; n++; }
      r/=n; g/=n; b/=n; return [r,g,b];
    }

    let renderer, scene, camera, controls, sprites=[];

    function init3D(){
      if (renderer) return;
      renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
      renderer.setSize(view3d.clientWidth, view3d.clientHeight);
      renderer.setPixelRatio(Math.min(2, window.devicePixelRatio||1));
      view3d.appendChild(renderer.domElement);
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(55, view3d.clientWidth/view3d.clientHeight, 0.01, 100);
      camera.position.set(1.6,1.6,1.6);
      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      const grid = new THREE.GridHelper(1,10,0x335577,0x223344); grid.rotation.x=Math.PI/2; grid.position.set(.5,.5,.0); scene.add(grid);
      const box = new THREE.Box3Helper(new THREE.Box3(new THREE.Vector3(0,0,0), new THREE.Vector3(1,1,1)), 0x446688); scene.add(box);
      const amb = new THREE.AmbientLight(0xffffff, 1.0); scene.add(amb);

      window.addEventListener('resize', ()=>{
        renderer.setSize(view3d.clientWidth, view3d.clientHeight);
        camera.aspect = view3d.clientWidth/view3d.clientHeight; camera.updateProjectionMatrix();
      });

      function animate(){ requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }
      animate();
    }

    function clear3D(){ if (!scene) return; for (const s of sprites){ scene.remove(s); s.material.map?.dispose?.(); s.material.dispose(); } sprites.length=0; }

    function spriteFromImage(img){
      const tex = new THREE.Texture(img); tex.needsUpdate = true; tex.colorSpace = THREE.SRGBColorSpace;
      const mat = new THREE.SpriteMaterial({ map: tex, depthTest: true, sizeAttenuation: true });
      const spr = new THREE.Sprite(mat); const scale = 0.08; spr.scale.set(scale, scale * img.naturalHeight/img.naturalWidth, 1);
      return spr;
    }

    const state = { metas:[], images:[], avg:[], coords3:[] };

    function computeCoords(space){
      const coords = new Array(state.images.length);
      for (let i=0;i<state.images.length;i++){
        const [r,g,b] = state.avg[i];
        if (space==='rgb'){
          coords[i] = [r/255, g/255, b/255];
        } else {
          const [hh, ss, vv] = rgb2hsv(r,g,b);
          coords[i] = [hh, ss, vv];
        }
      }
      state.coords3 = coords;
    }

    function render3D(){
      init3D(); clear3D();
      for (let i=0;i<state.images.length;i++){
        const spr = spriteFromImage(state.images[i]);
        const [x,y,z] = state.coords3[i];
        spr.position.set(x, y, z);
        scene.add(spr); sprites.push(spr);
      }
      controls.target.set(0.5,0.5,0.5); camera.position.set(1.6,1.6,1.6); controls.update();
      view3d.style.display = '';
    }

    async function run(){
      goBtn.disabled = true; repackBtn.disabled = true; setProgress(0.02);
      const n = parseInt(countEl.value,10); const s = parseInt(thumbEl.value,10);
      let metas;
      if (customFiles.length > 0) {
        metas = customFiles.map((file, idx) => ({ id: idx, url: URL.createObjectURL(file) }));
      } else {
        metas = await fetchPicsumList(n, s);
      }
      state.metas = metas; setProgress(0.08);

      const imgs = await Promise.all(metas.map(m => loadImage(m.url)));
      state.images = imgs;
      state.avg = imgs.map(averageColor);
      computeCoords(spaceEl.value);

      render3D();
      setProgress(1); setTimeout(()=>setProgress(0), 350);
      goBtn.disabled = false; repackBtn.disabled = false;
    }

    function repack(){ computeCoords(spaceEl.value); render3D(); }

    goBtn.addEventListener('click', run);
    repackBtn.addEventListener('click', repack);

    run();
  </script>
</body>
</html>
