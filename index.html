<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>ArloTools</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="theme.css">
  <style>
    /* Global reset for consistency across browsers */
    *, *::before, *::after {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html, body {
      height: 100%;
      overflow: hidden;
      background: var(--bg);
      color: var(--text);
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    :root {
      color-scheme: light;
      --bg: #ffffff;
      --panel: #ffffff;
      --panel-hover: #f0f0f0;
      --panel-active: #eaeaea;
      --accent: #000000;
      --text: #000000;
      --muted: #444444;
      --border: #000000;
      --divider: #cccccc;
      font-family: "Space Mono", "IBM Plex Mono", "Courier New", monospace;
      line-height: 1.4;
    }

    body {
      display: flex;
    }

    .sidebar {
      width: 320px;
      max-width: 100vw;
      transition: all 0.3s ease;
      background: var(--bg);
      border-right: 2px solid var(--border);
      padding: 20px 26px 32px;
      display: flex;
      flex-direction: column;
      gap: 20px;
      position: relative;
      z-index: 10;
    }

    .sidebar h1 {
      margin: 0;
      padding-bottom: 12px;
      border-bottom: 2px solid var(--divider);
    }

    .sidebar.hidden {
      display: none;
    }

    .main-wrapper {
      flex: 1;
      display: flex;
      flex-direction: column;
      height: 100vh;
      width: 100%;
    }

    .search-wrapper {
      position: relative;
    }

    .search-wrapper input {
      width: 100%;
      padding: 12px 16px 12px 48px;
      border: 2px solid var(--border);
      background: var(--panel);
      color: inherit;
      font-size: 0.95rem;
      outline: none;
    }

    .search-wrapper svg {
      position: absolute;
      top: 50%;
      left: 14px;
      width: 22px;
      height: 22px;
      transform: translateY(-50%);
      fill: var(--border);
      pointer-events: none;
    }

    #tool-list {
      flex: 1 1 auto;
      overflow-y: auto;
      display: grid;
      gap: 14px;
    }

    .tool-button {
      display: block;
      width: 100%;
      padding: 12px 14px;
      border: 2px solid var(--border);
      background: var(--panel);
      font-size: 0.85rem;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      text-align: left; /* left align tool names */
      cursor: pointer;
    }

    .tool-button.active {
      background: var(--panel-active);
      border-color: var(--accent);
      color: var(--accent);
    }

    main {
      flex: 1 1 auto;
      display: flex;
      flex-direction: column;
      padding: 0;
    }

    .toolbar {
      display: flex;
      align-items: center;
      padding: 0 12px;
      height: 40px;
      background: var(--panel);
      border: 2px solid var(--border);
      font-size: 0.9rem;
      font-weight: bold;
      gap: 12px;
      position: relative;
    }

    #sidebar-toggle {
      width: 40px;
      height: 40px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      font-weight: bold;
      cursor: pointer;
      font-size: 1rem;
      position: absolute;
      top: 0;
      left: 0;
      z-index: 20;
    }

    .toolbar #tool-name {
      margin-left: 52px;
      flex: 1;
    }

    .frame-container {
      flex: 1;
      position: relative;
      overflow: hidden;
      background: var(--panel);
      border: 2px solid var(--border);
    }

    iframe {
      width: 100%;
      height: 100%;
      border: none;
      background: var(--panel);
    }
  </style>
</head>
<body>
  <aside class="sidebar" id="sidebar">
    <h1><span style="border: 2px solid var(--border); padding: 0.25em 0.45em; background: var(--panel);">AT</span> ArloTools</h1>
    <label class="search-wrapper">
      <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M10.5 3a7.5 7.5 0 015.977 12.072l3.226 3.225a1 1 0 01-1.414 1.415l-3.226-3.226A7.5 7.5 0 1110.5 3zm0 2a5.5 5.5 0 100 11 5.5 5.5 0 000-11z"/></svg>
      <input id="search" type="search" placeholder="Search tools..." autocomplete="off">
    </label>
    <div id="tool-list" role="listbox"></div>
  </aside>
  <div class="main-wrapper">
    <main>
      <div class="toolbar">
        <button id="sidebar-toggle">☰</button>
        <span id="tool-name">Choose a tool</span>
        <a id="open-new-tab" href="#" target="_blank" rel="noopener">↗</a>
      </div>
      <div class="frame-container">
        <iframe id="tool-frame" title="Selected tool" hidden></iframe>
      </div>
    </main>
  </div>
  <script>
    document.addEventListener("DOMContentLoaded", () => {
      const TOOL_DIRECTORY = "tools/";
      const toolList = document.getElementById("tool-list");
      const searchInput = document.getElementById("search");
      const iframe = document.getElementById("tool-frame");
      const toolName = document.getElementById("tool-name");
      const openNewTab = document.getElementById("open-new-tab");
      const sidebar = document.getElementById("sidebar");
      const mainWrapper = document.querySelector(".main-wrapper");
      const toggleBtn = document.getElementById("sidebar-toggle");
      searchInput.disabled = true;
      toolList.textContent = "Loading tools...";

      const updateButtonIcon = () => {
        if (sidebar.classList.contains("hidden")) {
          toggleBtn.textContent = "☰"; // menu icon when closed
        } else {
          toggleBtn.textContent = "←"; // left arrow when open
        }
      };

      toggleBtn.addEventListener("click", () => {
        sidebar.classList.toggle("hidden");
        mainWrapper.style.width = sidebar.classList.contains("hidden") ? "100vw" : "calc(100vw - 320px)";
        updateButtonIcon();
      });

      updateButtonIcon();

      const toUrl = (file) => encodeURI(file).replace(/#/g, "%23");

      const injectTheme = (doc) => {
        if (!doc) return;
        const link = doc.createElement("link");
        link.rel = "stylesheet";
        link.href = "../theme.css";
        doc.head.appendChild(link);
      };

      const selectTool = (tool, button) => {
        document.querySelectorAll(".tool-button").forEach(btn => btn.classList.remove("active"));
        button.classList.add("active");
        const url = toUrl(`${TOOL_DIRECTORY}${tool.file}`);
        iframe.src = url;
        iframe.hidden = false;
        toolName.textContent = tool.name;
        openNewTab.href = url;

        iframe.addEventListener("load", () => {
          try {
            injectTheme(iframe.contentDocument);
          } catch (e) {
            console.warn("Could not inject theme:", e);
          }
        }, { once: true });
      };

      const normaliseName = (file) => {
        const base = file.replace(/\.html?$/i, "");
        const decoded = (() => {
          try {
            return decodeURIComponent(base);
          } catch (error) {
            return base;
          }
        })();
        return decoded.trim();
      };

      const parseDirectoryListing = (markup) => {
        const parser = new DOMParser();
        const doc = parser.parseFromString(markup, "text/html");
        const links = Array.from(doc.querySelectorAll("a"));
        return links
          .map((link) => link.getAttribute("href") || "")
          .map((href) => href.replace(/^\.\/?/, ""))
          .filter((href) => href && href.toLowerCase().endsWith(".html"))
          .map((href) => decodeURIComponent(href.split("/").pop() || ""));
      };

      const fetchManifest = async () => {
        try {
          const response = await fetch(`${TOOL_DIRECTORY}manifest.json`, { cache: "no-cache" });
          if (!response.ok) return null;
          const data = await response.json();
          if (Array.isArray(data)) return data;
          if (Array.isArray(data?.files)) return data.files;
          return null;
        } catch (error) {
          console.warn("Unable to load manifest:", error);
          return null;
        }
      };

      const getConfig = () => {
        const globalConfig = window.ARLO_TOOLS_CONFIG || {};
        const dataset = document.body?.dataset || {};
        const normaliseList = (value) => {
          if (!value) return [];
          if (Array.isArray(value)) return value;
          if (typeof value === "string") {
            return value
              .split(",")
              .map((item) => item.trim())
              .filter(Boolean);
          }
          return [];
        };

        return {
          githubOwner: globalConfig.githubOwner || dataset.githubOwner || "",
          githubRepo: globalConfig.githubRepo || dataset.githubRepo || "",
          githubBranch: globalConfig.githubBranch || dataset.githubBranch || "",
          githubBranches: normaliseList(globalConfig.githubBranches || dataset.githubBranches),
          githubToken: globalConfig.githubToken || "",
          disableGitHubLookup: Boolean(globalConfig.disableGitHubLookup || dataset.disableGithubLookup)
        };
      };

      const inferGitHubProject = () => {
        const { hostname, pathname } = window.location;
        if (!hostname.endsWith(".github.io")) return { owner: "", repoCandidates: [] };

        const owner = hostname.replace(/\.github\.io$/i, "");
        const pathSegments = pathname.replace(/^\/+/, "").split("/").filter(Boolean);
        const repoCandidates = [];

        if (pathSegments.length) {
          repoCandidates.push(pathSegments[0]);
        }

        repoCandidates.push(`${owner}.github.io`);

        return { owner, repoCandidates };
      };

      const fetchGitHubListing = async () => {
        const config = getConfig();
        if (config.disableGitHubLookup) return [];

        let owner = config.githubOwner;
        let repo = config.githubRepo;

        const inferred = inferGitHubProject();
        if (!owner && inferred.owner) owner = inferred.owner;

        const repoCandidates = new Set();
        if (repo) repoCandidates.add(repo);
        if (inferred.repoCandidates) {
          inferred.repoCandidates.forEach((candidate) => {
            if (candidate) repoCandidates.add(candidate);
          });
        }

        if (!owner || !repoCandidates.size) return [];

        const branches = Array.from(new Set([
          config.githubBranch,
          ...(config.githubBranches || []),
          "main",
          "master"
        ].filter(Boolean)));

        const headers = {
          Accept: "application/vnd.github+json"
        };

        if (config.githubToken) {
          headers.Authorization = `Bearer ${config.githubToken}`;
        }

        const directory = TOOL_DIRECTORY.replace(/\/+$/, "");

        for (const repoCandidate of repoCandidates) {
          for (const branch of branches) {
            const url = `https://api.github.com/repos/${owner}/${repoCandidate}/contents/${directory}?ref=${encodeURIComponent(branch)}`;
            try {
              const response = await fetch(url, { headers, cache: "no-cache" });
              if (!response.ok) {
                if (response.status === 404) {
                  continue;
                }
                console.warn(`GitHub lookup failed (${response.status}): ${await response.text()}`);
                continue;
              }
              const data = await response.json();
              if (!Array.isArray(data)) continue;
              return data
                .filter((entry) => entry?.type === "file")
                .map((entry) => entry.name)
                .filter((name) => typeof name === "string" && name.toLowerCase().endsWith(".html"));
            } catch (error) {
              console.warn("Unable to query GitHub API:", error);
            }
          }
        }

        return [];
      };

      const fetchDirectoryListing = async () => {
        try {
          const response = await fetch(TOOL_DIRECTORY, { cache: "no-cache" });
          if (!response.ok) throw new Error(`Unable to list tools: ${response.status}`);
          const contentType = response.headers.get("content-type") || "";
          if (contentType.includes("application/json")) {
            const data = await response.json();
            if (Array.isArray(data)) return data;
            if (Array.isArray(data?.files)) return data.files;
            return [];
          }
          const markup = await response.text();
          return parseDirectoryListing(markup);
        } catch (error) {
          console.warn("Directory listing lookup failed:", error);
          return [];
        }
      };

      const fetchToolFiles = async () => {
        const manifestFiles = await fetchManifest();
        if (Array.isArray(manifestFiles) && manifestFiles.length) {
          return manifestFiles;
        }

        const directoryFiles = await fetchDirectoryListing();
        if (Array.isArray(directoryFiles) && directoryFiles.length) {
          return directoryFiles;
        }

        const githubFiles = await fetchGitHubListing();
        if (Array.isArray(githubFiles) && githubFiles.length) {
          return githubFiles;
        }

        return [];
      };

      const renderTools = (toolFiles) => {
        toolList.innerHTML = "";
        if (!toolFiles.length) {
          console.warn("No tools detected. Ensure your server exposes a directory listing for the tools folder, set ARLO_TOOLS_CONFIG with GitHub details, or provide a manifest at tools/manifest.json.");
          const emptyState = document.createElement("div");
          emptyState.style.display = "flex";
          emptyState.style.flexDirection = "column";
          emptyState.style.gap = "0.75rem";

          const message = document.createElement("p");
          message.textContent = "No tools found in the tools folder.";

          const hint = document.createElement("p");
          hint.style.fontSize = "0.8rem";
          hint.style.lineHeight = "1.4";
          hint.textContent = "If you're hosting ArloTools on GitHub Pages, expose the repository owner/repo via ARLO_TOOLS_CONFIG or data attributes so the index can query the GitHub API automatically.";

          emptyState.appendChild(message);
          emptyState.appendChild(hint);
          toolList.appendChild(emptyState);
          iframe.hidden = true;
          toolName.textContent = "Choose a tool";
          openNewTab.removeAttribute("href");
          searchInput.disabled = true;
          return;
        }

        searchInput.disabled = false;
        searchInput.value = "";

        const uniqueFiles = Array.from(new Set(toolFiles));

        const tools = uniqueFiles
          .filter(Boolean)
          .map((file) => ({
            file,
            name: normaliseName(file) || file.replace(/\.html?$/i, "")
          }))
          .sort((a, b) => a.name.localeCompare(b.name, undefined, { sensitivity: "base" }));

        tools.forEach((tool) => {
          const button = document.createElement("button");
          button.type = "button";
          button.className = "tool-button";
          button.textContent = tool.name;
          button.dataset.toolName = tool.name.toLowerCase();
          button.title = tool.file;
          button.addEventListener("click", () => selectTool(tool, button));
          toolList.appendChild(button);
        });

        searchInput.addEventListener("input", () => {
          const query = searchInput.value.trim().toLowerCase();
          toolList.querySelectorAll(".tool-button").forEach((button) => {
            const match = button.dataset.toolName.includes(query);
            button.style.display = match ? "block" : "none";
          });
        });
      };

      fetchToolFiles().then(renderTools);
    });
  </script>
</body>
</html>
