<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MIDI → Neumes (Square‑Note) — Single‑File HTML</title>
  <style>
    :root { --bg:#fafafa; --fg:#111; --muted:#666; --border:#ddd; --accent:#ef4444; }
    * { box-sizing: border-box; }
    body { margin: 0; font: 15px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; color: var(--fg); background: var(--bg); }
    header { padding: 20px 16px 8px; max-width: 1200px; margin: 0 auto; }
    h1 { margin: 0 0 6px; font-size: 22px; }
    p.lede { margin: 0 0 16px; color: var(--muted); }
    .wrap { max-width: 1200px; margin: 0 auto; padding: 0 16px 32px; }
    .controls { display: grid; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); gap: 10px; margin-bottom: 12px; }
    .card { background: #fff; border: 1px solid var(--border); border-radius: 14px; padding: 10px 12px; display: flex; align-items: center; gap: 8px; }
    label { font-size: 13px; color: var(--fg); }
    select, input[type="file"], button, input[type="range"] { font: inherit; }
    select { padding: 6px 8px; border: 1px solid var(--border); border-radius: 10px; background: white; }
    button { padding: 8px 10px; border: 1px solid var(--border); background: #fff; border-radius: 12px; cursor: pointer; }
    button:hover { box-shadow: 0 1px 6px rgba(0,0,0,.08); }
    .alert { border: 1px solid #fecaca; background: #fff1f2; color: #991b1b; padding: 10px 12px; border-radius: 10px; margin: 8px 0 12px; }
    #neumes-svg-container { background: #fff; border: 1px solid var(--border); border-radius: 14px; padding: 10px; overflow: auto; min-height: 160px; }
    details { margin-top: 10px; color: var(--muted); }
    details > summary { cursor: pointer; color: #222; }
    .spacer { flex: 1; }
    .pill { padding: 2px 8px; border: 1px solid var(--border); border-radius: 999px; font-size: 12px; color: #333; }
    .description { max-width: 900px; margin: 0 auto; padding: 8px 16px; font-size: 0.9rem; line-height: 1.4; border-bottom:1px solid #ddd; }
  </style>
</head>
<body>
  <header>
    <h1>MIDI → Neumes (square‑note) Converter</h1>
    <p class="lede">Upload a MIDI file, choose a melodic track, and render approximate medieval chant neumes (punctum, podatus, clivis, torculus, porrectus, scandicus, climacus) on a 4‑line staff. Export the SVG — and now, <strong>play it back with a moving cursor</strong>.</p>
  </header>
  <div class="description">
    <p>This tool converts modern MIDI melodies into an approximate square‑note notation. Neumes are a medieval precursor to modern staff notation, and capture the general contour of a melody rather than exact durations. You can read more about them on <a href="https://en.wikipedia.org/wiki/Neume#Western_plainchant" target="_blank">Wikipedia</a>. If you’d like to see an example without uploading anything, click <b>Load Demo</b> to load a short built‑in MIDI sample.</p>
    <button id="loadDemo" type="button">Load Demo</button>
  </div>
  <main class="wrap">
    <section class="controls" aria-label="controls">
      <div class="card">
        <label for="file">MIDI file</label>
        <input id="file" type="file" accept=".mid,.midi" />
      </div>
      <div class="card">
        <label for="track">Track</label>
        <select id="track" disabled></select>
      </div>
      <div class="card">
        <label for="policy">Melody pick</label>
        <select id="policy">
          <option value="highest">Prefer highest</option>
          <option value="lowest">Prefer lowest</option>
        </select>
      </div>
      <div class="card">
        <label for="labels">Labels</label>
        <input id="labels" type="checkbox" />
        <span class="muted">Show neume type</span>
        <div class="spacer"></div>
        <button id="download" title="Download SVG" disabled>Download SVG</button>
      </div>
      <div class="card" id="transport">
        <button id="play" disabled>▶︎ Play</button>
        <button id="stop" disabled>■ Stop</button>
        <span class="pill" id="tempo">Tempo: —</span>
        <label for="wave" style="margin-left:8px">Wave</label>
        <select id="wave">
          <option value="sine">sine</option>
          <option value="triangle">triangle</option>
          <option value="square">square</option>
          <option value="sawtooth">sawtooth</option>
        </select>
        <label for="volume" style="margin-left:8px">Vol</label>
        <input id="volume" type="range" min="0" max="1" step="0.01" value="0.3" />
      </div>
    </section>
    <div id="error" class="alert" style="display:none"></div>
    <div id="neumes-svg-container">
      <div style="padding:16px; color: var(--muted);">Upload a MIDI file or load the demo to see the rendering here.</div>
    </div>
    <details>
      <summary>About the mapping</summary>
      <div>
        <p>Neumes are grouped heuristically from melodic motion: single notes → <em>punctum</em>; up by step → <em>podatus</em>; down → <em>clivis</em>; up–down → <em>torculus</em>; down–up → <em>porrectus</em>; long ascents → <em>scandicus</em>; long descents → <em>climacus</em>. Spacing is loosely proportional to duration with a minimum width per neume, which the playback cursor mirrors for visual alignment.</p>
        <p>Staff placement centers around your melody’s median pitch. Each semitone maps to a small vertical step for compact square‑note appearance; this is a pragmatic sketch rather than a scholarly engraving engine.</p>
      </div>
    </details>
  </main>
  <script>
  'use strict';
  // Demo MIDI encoded in base64 (a minimal scale)
  const demoMidi = 'TVRoZAAAAAYAAAABAGBNVHJrAAAAEwD/UQMHoSAAkDxAYIA8QAD/LwA=';
  // ------------------------ MIDI PARSER ------------------------
  function readVarInt(view, idx){ let result=0, b, i=idx; do { b=view[i++]; result=(result<<7)|(b & 0x7f); } while(b & 0x80); return {value:result,next:i}; }
  function readStr(view, idx, len){ let s=""; for(let i=0;i<len;i++) s+=String.fromCharCode(view[idx+i]); return s; }
  function readU32(view, idx){ return (view[idx]<<24)|(view[idx+1]<<16)|(view[idx+2]<<8)|view[idx+3]; }
  function readU16(view, idx){ return (view[idx]<<8)|view[idx+1]; }
  function parseMIDI(arrayBuffer){ const u8 = new Uint8Array(arrayBuffer); let i=0; if (readStr(u8,i,4)!=="MThd") throw new Error("Not a MIDI file"); i+=4; const headerLen=readU32(u8,i); i+=4; const format=readU16(u8,i); i+=2; const ntrks=readU16(u8,i); i+=2; const division=readU16(u8,i); i+=2; i+=(headerLen-6); const ticksPerBeat = (division & 0x8000) ? 480 : division; const tracks=[]; let globalTempo=500000; for (let t=0;t<ntrks;t++){ if (readStr(u8,i,4)!=="MTrk") throw new Error("Bad track header"); i+=4; const len=readU32(u8,i); i+=4; let ptr=i; const end=i+len; let absTicks=0; let status=null; const trackName={value:`Track ${t+1}`}; const notes=[]; const active=new Map(); while(ptr<end){ const delta=readVarInt(u8,ptr); ptr=delta.next; absTicks+=delta.value; let b=u8[ptr++]; if (b<0x80){ ptr--; if(status===null) throw new Error("Running status without status byte"); } else status=b; const eventType=status & 0xf0; if (status===0xff){ const metaType=u8[ptr++]; const li=readVarInt(u8,ptr); ptr=li.next; const mlen=li.value; if (metaType===0x03){ trackName.value=readStr(u8,ptr,mlen)||trackName.value; } else if (metaType===0x51 && mlen===3){ globalTempo=(u8[ptr]<<16)|(u8[ptr+1]<<8)|u8[ptr+2]; } ptr+=mlen; } else if (status===0xf0 || status===0xf7){ const li=readVarInt(u8,ptr); ptr=li.next+li.value; } else if (eventType===0x80 || eventType===0x90){ const chan=status & 0x0f; const pitch=u8[ptr++]; const vel=u8[ptr++]; if (eventType===0x90 && vel>0){ active.set(`${chan}:${pitch}`,{start:absTicks,velocity:vel,pitch,chan}); } else { const key=`${chan}:${pitch}`; const on=active.get(key); if (on){ notes.push({pitch,start:on.start,end:absTicks,velocity:on.velocity,chan:on.chan}); active.delete(key);} } } else if (eventType===0xa0 || eventType===0xb0 || eventType===0xe0){ ptr+=2; } else if (eventType===0xc0 || eventType===0xd0){ ptr+=1; } else { break; } } for (const [,on] of active){ notes.push({pitch:on.pitch,start:on.start,end:absTicks,velocity:on.velocity,chan:on.chan}); } tracks.push({ name: trackName.value, notes: notes.sort((a,b)=>a.start-b.start), tempoUSQ: globalTempo }); i=end; } return { format, ticksPerBeat, tracks }; }
  // ----------------- MELODY EXTRACTION / CLEANUP -----------------
  function toMonophonic(notes, policy="highest"){ const events=[]; for (const n of notes){ events.push({t:n.start,type:"on",n}); events.push({t:n.end,type:"off",n}); } events.sort((a,b)=> a.t-b.t || (a.type==="off"?-1:1)); const active=new Map(); const mono=[]; let lastNote=null; let lastTime=0; function pick(){ if (!active.size) return null; const arr=[...active.values()]; arr.sort((a,b)=> policy==="highest"? b.pitch-a.pitch : a.pitch-b.pitch); return arr[0]; } for (const e of events){ if (e.type==="on") active.set(e.n,e.n); else active.delete(e.n); const cur=pick(); if (cur!==lastNote){ const t=e.t; if (lastNote){ mono.push({pitch:lastNote.pitch,start:lastTime,end:t,velocity:lastNote.velocity}); } lastNote=cur; lastTime=t; } } if (lastNote) mono.push({pitch:lastNote.pitch,start:lastTime,end:events[events.length-1].t,velocity:lastNote.velocity}); return mono.filter(n=>n.end>n.start); }
  // ------------------------ NEUME GROUPING ------------------------
  function groupNeumes(mono, ticksPerBeat){ const groups=[]; const n=mono.length; let i=0; while(i<n){ const a=mono[i], b=mono[i+1], c=mono[i+2]; if(!b){ groups.push({type:"punctum", notes:[a]}); i++; continue; } const d1=b.pitch-a.pitch; if(!c){ if(d1>0) groups.push({type:"podatus", notes:[a,b]}); else if(d1<0) groups.push({type:"clivis", notes:[a,b]}); else groups.push({type:"bivirga", notes:[a,b]}); i+=2; continue; } const d2=c.pitch-b.pitch; if(d1>0 && d2>0){ const run=[a,b,c]; let j=i+3; while(j<n && mono[j].pitch>mono[j-1].pitch){ run.push(mono[j]); j++; } groups.push({type:"scandicus", notes:run}); i=j; continue; } if(d1<0 && d2<0){ const run=[a,b,c]; let j=i+3; while(j<n && mono[j].pitch<mono[j-1].pitch){ run.push(mono[j]); j++; } groups.push({type:"climacus", notes:run}); i=j; continue; } if(d1>0 && d2<0){ groups.push({type:"torculus", notes:[a,b,c]}); i+=3; continue; } if(d1<0 && d2>0){ groups.push({type:"porrectus", notes:[a,b,c]}); i+=3; continue; } if(d1>0) groups.push({type:"podatus", notes:[a,b]}); else if(d1<0) groups.push({type:"clivis", notes:[a,b]}); else groups.push({type:"bivirga", notes:[a,b]}); i+=2; } for (const g of groups){ let ticks=0; for (const nn of g.notes) ticks+=(nn.end-nn.start); g.ticks=ticks; g.beats = ticksPerBeat ? ticks/ticksPerBeat : ticks/480; } return groups; }
  // ------------------------ STAFF MAPPING ------------------------
  function computePitchCenter(notes){ if(!notes.length) return 60; const arr=notes.map(n=>n.pitch).sort((a,b)=>a-b); return arr[Math.floor(arr.length/2)]; }
  function pitchToY(pitch, centerPitch, step=7){ return -(pitch-centerPitch)*step; }
  // ------------------------ SVG RENDERING ------------------------
  function renderNeumesSVG({container, groups, centerPitch, options}){
    const width = options?.width ?? 1400;
    const margin = options?.margin ?? 32;
    const staffHeight = options?.staffHeight ?? 120;
    const step = options?.step ?? 7;
    const noteSize = options?.noteSize ?? 13;
    const baseSpacing = options?.baseSpacing ?? 26;
    const labelNeumes = options?.labelNeumes ?? false;
    let totalBeats=0; for (const g of groups) totalBeats += Math.max(0.5, g.beats);
    const pxPerBeat=60; const totalWidth=Math.max(width, margin*2 + totalBeats*pxPerBeat + groups.length*baseSpacing);
    let x = margin + 10; const yMid = margin + staffHeight/2 + 90; const lineGap = staffHeight / 3;
    const svgNS = 'http://www.w3.org/2000/svg';
    const svg = document.createElementNS(svgNS,'svg');
    const svgH = yMid + staffHeight + margin;
    svg.setAttribute('width', totalWidth);
    svg.setAttribute('height', svgH);
    svg.setAttribute('viewBox', `0 0 ${totalWidth} ${svgH}`);
    const bg = document.createElementNS(svgNS,'rect'); bg.setAttribute('x',0); bg.setAttribute('y',0); bg.setAttribute('width', totalWidth); bg.setAttribute('height', svgH); bg.setAttribute('fill','#fff'); svg.appendChild(bg);
    // Staff lines (4)
    const staffYTop = yMid - staffHeight/2;
    for (let l=0;l<4;l++){ const y = staffYTop + l*lineGap; const line=document.createElementNS(svgNS,'line'); line.setAttribute('x1', margin); line.setAttribute('y1', y); line.setAttribute('x2', totalWidth - margin); line.setAttribute('y2', y); line.setAttribute('stroke', '#111'); line.setAttribute('stroke-width', '1'); svg.appendChild(line); }
    function drawSquare(cx, cy){ const half=noteSize/2; const poly=document.createElementNS(svgNS,'polygon'); const pts=[[cx-half, cy-half],[cx+half, cy-half],[cx+half, cy+half],[cx-half, cy+half]].map(p=>p.join(',')).join(' '); poly.setAttribute('points', pts); poly.setAttribute('stroke','black'); poly.setAttribute('fill','black'); return poly; }
    function connector(x1,y1,x2,y2){ const ln=document.createElementNS(svgNS,'line'); ln.setAttribute('x1',x1); ln.setAttribute('y1',y1); ln.setAttribute('x2',x2); ln.setAttribute('y2',y2); ln.setAttribute('stroke','black'); ln.setAttribute('stroke-width','1.2'); return ln; }
    const segments=[]; let beatCursor = 0;
    for (const g of groups){ const usedBeats = Math.max(0.5, g.beats); const advance = baseSpacing + pxPerBeat * usedBeats; const ns = g.notes; const ys = ns.map(n => yMid + pitchToY(n.pitch, centerPitch, step)); const innerStep = Math.min(18, Math.max(12, advance / (ns.length + 1))); const xStart = x; const xEnd = x + advance; segments.push({ startBeat: beatCursor, endBeat: beatCursor + usedBeats, xStart, xEnd }); if (g.type==='punctum' || g.type==='bivirga'){ for (let k=0;k<ns.length;k++){ const cx = x + innerStep*(k+1); svg.appendChild(drawSquare(cx, ys[k])); } } else if (g.type==='podatus'){ const cx = x + innerStep*1.2; svg.appendChild(drawSquare(cx, ys[0])); svg.appendChild(drawSquare(cx, ys[1]-noteSize*0.75)); svg.appendChild(connector(cx, ys[0]-noteSize*0.4, cx, ys[1]-noteSize*0.4)); } else if (g.type==='clivis'){ const cx = x + innerStep*1.2; svg.appendChild(drawSquare(cx, ys[0])); svg.appendChild(drawSquare(cx+innerStep*0.7, ys[1]+noteSize*0.6)); svg.appendChild(connector(cx+noteSize*0.6, ys[0], cx+innerStep*0.7-noteSize*0.6, ys[1]+noteSize*0.6)); } else if (g.type==='torculus'){ const cx = x + innerStep; const yA=ys[0], yB=ys[1]-noteSize*0.6, yC=ys[2]; svg.appendChild(drawSquare(cx, yA)); svg.appendChild(drawSquare(cx+innerStep*0.7, yB)); svg.appendChild(drawSquare(cx+innerStep*1.4, yC+noteSize*0.4)); svg.appendChild(connector(cx+noteSize*0.6, yA, cx+innerStep*0.7-noteSize*0.4, yB)); svg.appendChild(connector(cx+innerStep*0.7+noteSize*0.6, yB, cx+innerStep*1.4-noteSize*0.6, yC+noteSize*0.4)); } else if (g.type==='porrectus'){ const cx = x + innerStep; const yA=ys[0]+noteSize*0.2, yB=ys[1], yC=ys[2]-noteSize*0.2; svg.appendChild(drawSquare(cx, yA)); svg.appendChild(drawSquare(cx+innerStep*0.8, yB)); svg.appendChild(drawSquare(cx+innerStep*1.6, yC)); svg.appendChild(connector(cx+noteSize*0.4, yA, cx+innerStep*1.6-noteSize*0.4, yC)); } else if (g.type==='scandicus'){ for (let k=0;k<ns.length;k++){ const cx=x+innerStep*(k+1); const lift=Math.max(0,(k-1))*(noteSize*0.45); svg.appendChild(drawSquare(cx, ys[k]-lift)); if (k>0) svg.appendChild(connector(cx-innerStep*0.6, ys[k-1]-Math.max(0,(k-2))*(noteSize*0.45), cx-noteSize*0.5, ys[k]-lift)); } } else if (g.type==='climacus'){ for (let k=0;k<ns.length;k++){ const cx=x+innerStep*(k+1); const drop=Math.max(0,(k-1))*(noteSize*0.45); svg.appendChild(drawSquare(cx, ys[k]+drop)); if (k>0) svg.appendChild(connector(cx-innerStep*0.6, ys[k-1]+Math.max(0,(k-2))*(noteSize*0.45), cx-noteSize*0.5, ys[k]+drop)); } } if (labelNeumes){ const text=document.createElementNS(svgNS,'text'); text.setAttribute('x', x+6); text.setAttribute('y', yMid - staffHeight - 18); text.setAttribute('font-size','12'); text.setAttribute('fill','#111'); text.textContent = g.type; svg.appendChild(text); } x += advance; beatCursor += usedBeats; }
    // Playhead line
    const playhead = document.createElementNS(svgNS,'line'); playhead.setAttribute('id','playhead'); playhead.setAttribute('x1', margin); playhead.setAttribute('x2', margin); playhead.setAttribute('y1', yMid - staffHeight/2 - 20); playhead.setAttribute('y2', yMid + staffHeight/2 + 20); playhead.setAttribute('stroke', getComputedStyle(document.documentElement).getPropertyValue('--accent') || '#ef4444'); playhead.setAttribute('stroke-width','2'); playhead.setAttribute('opacity','0.9'); svg.appendChild(playhead);
    container.innerHTML = '';
    container.appendChild(svg);
    return { svg, mapping: { segments, margin, totalWidth, yMid, staffHeight } };
  }
  // ----------------------------- UI LOGIC & PLAYBACK -----------------------------
  const $ = sel => document.querySelector(sel);
  const fileInput = $('#file');
  const trackSel = $('#track');
  const policySel = $('#policy');
  const labelsChk = $('#labels');
  const errorBox = $('#error');
  const dlBtn = $('#download');
  const svgContainer = document.getElementById('neumes-svg-container');
  const playBtn = $('#play');
  const stopBtn = $('#stop');
  const tempoBadge = $('#tempo');
  const waveSel = $('#wave');
  const volSlider = $('#volume');
  const loadDemoBtn = document.getElementById('loadDemo');
  let parsed = null; let trackIdx = 0; let policy = 'highest'; let labelNeumes = false;
  let renderInfo = null; // {svg, mapping}
  let mono = []; let groups = []; let centerPitch = 60; let beatsPerSecond = 2; let totalBeats = 0;
  // Playback state
  let ac = null, osc = null, gain = null; // single-voice synth
  let raf = 0; let startBeat = 0; let startTime = 0; let playing = false; let timeline = []; // [{pitch,startBeat,endBeat}]
  function setError(msg){ if (!msg){ errorBox.style.display='none'; errorBox.textContent=''; } else { errorBox.style.display='block'; errorBox.textContent = msg; } }
  function buildPlaybackTimeline(groups, ticksPerBeat){ const notes = []; let globalBeat = 0; for (const g of groups){ const usedBeats = Math.max(0.5, g.beats); const totalNoteBeats = g.ticks / (ticksPerBeat || 480); let scale = totalNoteBeats > 0 ? (usedBeats / totalNoteBeats) : (usedBeats / Math.max(1, g.notes.length)); let local = 0; for (const n of g.notes){ const nb = ( (n.end - n.start) / (ticksPerBeat || 480) ) * scale; notes.push({ pitch: n.pitch, startBeat: globalBeat + local, endBeat: globalBeat + local + nb }); local += nb; } globalBeat += usedBeats; } totalBeats = globalBeat; return notes; }
  function refresh(){ if (!parsed){ return; } const tracks = parsed.tracks || []; const selTrack = tracks[trackIdx] || tracks[0]; if (!selTrack){ setError('No note data found in this MIDI'); return; } setError(''); mono = toMonophonic(selTrack.notes, policy); groups = groupNeumes(mono, parsed.ticksPerBeat); centerPitch = computePitchCenter(mono); if (groups.length === 0){ svgContainer.innerHTML = '<div style="padding:16px;color:#666">No melodic content detected on this track.</div>'; dlBtn.disabled = true; playBtn.disabled = true; stopBtn.disabled = true; return; } renderInfo = renderNeumesSVG({ container: svgContainer, groups, centerPitch, options: { labelNeumes } }); dlBtn.disabled = false; playBtn.disabled = false; stopBtn.disabled = false; const selTrackTempo = selTrack.tempoUSQ || 500000; const spb = selTrackTempo / 1e6; beatsPerSecond = 1 / spb; tempoBadge.textContent = `Tempo: ${Math.round(60/spb)} bpm`; timeline = buildPlaybackTimeline(groups, parsed.ticksPerBeat); resetPlayhead(); }
  function populateTracks(){ trackSel.innerHTML = ''; const frag = document.createDocumentFragment(); (parsed.tracks||[]).forEach((tr, idx)=>{ const opt=document.createElement('option'); opt.value = String(idx); opt.textContent = `${idx+1}: ${tr.name} (${tr.notes.length} notes)`; frag.appendChild(opt); }); trackSel.appendChild(frag); trackSel.disabled = !(parsed.tracks && parsed.tracks.length); }
  function movePlayheadToBeat(beat){ if (!renderInfo) return; const { segments, margin } = renderInfo.mapping; if (!segments.length) return; const svg = svgContainer.querySelector('svg'); const ph = svg && svg.querySelector('#playhead'); if (!ph) return; const b = Math.max(0, Math.min(totalBeats, beat)); let seg = segments[segments.length-1]; for (let i=0;i<segments.length;i++){ if (b >= segments[i].startBeat && b <= segments[i].endBeat){ seg = segments[i]; break; } } const spanB = Math.max(1e-6, seg.endBeat - seg.startBeat); const t = (b - seg.startBeat) / spanB; const x = seg.xStart + t * (seg.xEnd - seg.xStart); ph.setAttribute('x1', x); ph.setAttribute('x2', x); const box = svg.getBoundingClientRect(); const container = svgContainer; const left = x - 60; const right = x + 60; const currentScroll = container.scrollLeft; if (left < currentScroll) container.scrollLeft = Math.max(0, left - 20); else if (right > currentScroll + container.clientWidth) container.scrollLeft = right - container.clientWidth + 20; }
  function currentNoteAtBeat(beat){ for (let i=0;i<timeline.length;i++){ const n = timeline[i]; if (beat >= n.startBeat && beat < n.endBeat) return { idx:i, n }; } return null; }
  function synthEnsure(){ if (!ac){ ac = new (window.AudioContext || window.webkitAudioContext)(); } if (!gain){ gain = ac.createGain(); gain.gain.value = Number(volSlider.value||0.3); gain.connect(ac.destination); } if (!osc){ osc = ac.createOscillator(); osc.type = waveSel.value || 'sine'; osc.connect(gain); osc.start(); } }
  function synthStop(){ if (osc){ try{ osc.stop(); }catch{} osc.disconnect(); osc=null; } if (gain){ gain.disconnect(); gain=null; } }
  function freqFromMidi(p){ return 440 * Math.pow(2, (p - 69)/12); }
  function resetPlayhead(){ startBeat = 0; startTime = 0; playing=false; movePlayheadToBeat(0); cancelAnimationFrame(raf); }
  function togglePlay(){ if (playing){ playing = false; cancelAnimationFrame(raf); synthStop(); playBtn.textContent = '▶︎ Play'; return; } synthEnsure(); startTime = ac.currentTime; const startAtBeat = startBeat; playBtn.textContent = '⏸ Pause'; playing = true; let lastIdx = -1; function tick(){ if (!playing) return; const now = ac.currentTime; const beat = startAtBeat + (now - startTime) * beatsPerSecond; movePlayheadToBeat(beat); const info = currentNoteAtBeat(beat); if (info){ if (info.idx !== lastIdx){ const freq = freqFromMidi(info.n.pitch); try { osc.frequency.setValueAtTime(freq, ac.currentTime); } catch { osc.frequency.value = freq; } if (gain) gain.gain.setTargetAtTime(Number(volSlider.value||0.3), ac.currentTime, 0.01); lastIdx = info.idx; } } else { if (gain) gain.gain.setTargetAtTime(0.0, ac.currentTime, 0.02); } if (beat >= totalBeats){ playing=false; playBtn.textContent='▶︎ Play'; synthStop(); startBeat = 0; movePlayheadToBeat(0); return; } raf = requestAnimationFrame(tick); } raf = requestAnimationFrame(tick); }
  function stopPlayback(){ playing=false; cancelAnimationFrame(raf); synthStop(); startBeat = 0; movePlayheadToBeat(0); playBtn.textContent='▶︎ Play'; }
  fileInput.addEventListener('change', ()=>{
    setError(''); dlBtn.disabled = true; svgContainer.innerHTML='<div style="padding:16px;color:#666">Parsing…</div>';
    const f = fileInput.files && fileInput.files[0];
    if (!f){ setError('No file selected'); svgContainer.innerHTML=''; return; }
    const reader = new FileReader();
    reader.onload = ()=>{ try { parsed = parseMIDI(reader.result); trackIdx = 0; populateTracks(); refresh(); } catch(err){ setError(err && err.message ? err.message : String(err)); svgContainer.innerHTML=''; } };
    reader.onerror = ()=>{ setError('Failed to read file'); svgContainer.innerHTML=''; };
    reader.readAsArrayBuffer(f);
  });
  trackSel.addEventListener('change', ()=>{ trackIdx = Number(trackSel.value||0); stopPlayback(); refresh(); });
  policySel.addEventListener('change', ()=>{ policy = policySel.value; stopPlayback(); refresh(); });
  labelsChk.addEventListener('change', ()=>{ labelNeumes = !!labelsChk.checked; refresh(); });
  dlBtn.addEventListener('click', ()=>{
    const svg = svgContainer.querySelector('svg');
    if (!svg) return;
    const src = new XMLSerializer().serializeToString(svg);
    const blob = new Blob([src], {type:'image/svg+xml;charset=utf-8'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = 'neumes.svg'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
  });
  playBtn.addEventListener('click', togglePlay);
  stopBtn.addEventListener('click', stopPlayback);
  waveSel.addEventListener('change', ()=>{ if (osc) osc.type = waveSel.value; });
  volSlider.addEventListener('input', ()=>{ if (gain) gain.gain.value = Number(volSlider.value||0.3); });
  // Load demo handler
  loadDemoBtn.addEventListener('click', () => {
    try {
      const binary = atob(demoMidi);
      const len = binary.length;
      const bytes = new Uint8Array(len);
      for (let i = 0; i < len; i++) bytes[i] = binary.charCodeAt(i);
      parsed = parseMIDI(bytes.buffer);
      trackIdx = 0;
      populateTracks();
      refresh();
    } catch(err) {
      setError(err && err.message ? err.message : String(err));
    }
  });
  </script>
</body>
</html>